\documentclass[12pt, a4paper]{article}
\usepackage[left=1cm, right=1.5cm, top=5cm, bottom=5cm]{geometry}
\usepackage{cite, hyperref, graphicx, mathtools, amsmath, amsfonts, amssymb}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\title {
  Questionário sobre SHA3 algoritmos de criptografia baseada em hash
}

\author {
  Lucas Tonussi, matr.: \textit{12106577}
}

\date{
  \today
}

\hypersetup {
  colorlinks,
  citecolor = NavyBlue,
  filecolor = NavyBlue,
  linkcolor = NavyBlue,
  urlcolor = NavyBlue
}

\begin{document}

\maketitle

\section{Questões}

\begin{enumerate}

\item Definição de função de \underline{hash} criptográfica.\\

  \begin{itemize}

    \item Função de \underline{hash} criptográfica é um tipo de função hash
    necessária para aplicações de segurança. É um algoritmo do qual é um
    problema intratável de se achar uma informação que mapeia para um resumo
    (unilateralidade), ou duas informações que mapeiam para um mesmo resumo
    (livre de colisões) (Stallings, pg 314).\\

    \item Para \textbf{funções hash}, a entrada é chamada de mensagem $m$, e a
    saída é chamada a mensagem moída ou um valor hash. O tamanho da mensagem
    pode varias é claro; mas o tamanho da mensagem moída é fixo. Uma função de
    hash criptográfico é uma função hash que é desenhada para prover
    propriedades especiais, incluindo resistência a colisão e resistência a
    bilateralidade (pre-imagem), que são importantíssimas para muitas aplicações
    envolvendo segurança da informação.\\

  \end{itemize}

\item Propriedades.\\

Requerimentos e Segurança para funções de resumos criptográfico, existem alguns
porém a questão pede apenas 3  requisitos. (Stallings Página 323 Capítulo 11.3,
Tabela 11.1,  Linhas 4, 5, 6).\\

  \begin{itemize}
    \label{tiposataque}
    \item Preimage resistant (one-way property): $h = H(m),\ h \rightarrow m$
    \underline{\color{red} \textbf{mas}} \underline{\color{red} \textbf{nunca}}
    $h \leftarrow m$.\\

    \item Second preimage resistant (weak collision resistant): $len(H_1(m_1)) =
    len(H_2(m_2)) = \ldots = len(H_n(m_n))$ \underline{\color{red}
    \textbf{deve}} \underline{\color{red} \textbf{ser}} $len(H(m)) \le
    len(m)$.\\

    \item Collision resistant (strong collision resistant): $h_1 = H(m_1),\
    h_2=H(m_2),\ \ldots,\ h_n=H(m_n)\  \vert\ h_1 \not=\ h_2 \not=,\ \ldots,\
    \not=\ h_n$.\\
  \end{itemize}

\item Explicar o \textbf{SHA3}.\\

\label{sha3-inicial}
É um acrônimo para Secure Hash Algorithm-3 (DRAFT FIPS 202, pg 4). É também uma
família de algoritmos \underline{Hash}-Criptográfico. Ele suplementa as famílias
já depreciadas, SHA1 e SHA2. Cada função do SHA-3 é baseado no algoritmo
\textsc{KECCAK}\cite{keccak} (NIST Instituto Nacional de Padrões e Tecnologia).
O padrão também inclui o \textsc{Keccak-p} que implementa permutações para o
mesmo (p é de permutar). Esse padrão SHA3 é aplicado em todos os departamentos
federais e agencias de proteção a informações secretas (DRAFT FIPS 202, pg 5).
Quem mantêm os código e chaves é o NIST, o documento de especificação do SHA3 é
o FIPS 202. Quem aprova as implementação é a Secretaria do Comércio
(Estadunidense). A família SHA3 contém 6 implementações, 4 delas são funções de
hash criptográfico:\\

  \begin{itemize}
    \item SHA3-224 \item SHA3-256 \item SHA3-384 \item SHA3-512\\
  \end{itemize}

e as outras duas são do tipo Funções de
Vazão-Estendida\footnote{Extendable-Output Functions ou XOFs} são eles:\\

  \begin{itemize}
    \item SHAKE128 \item SHAKE256 \footnote{SHAKE, Secure Hash Algorithm
    Keccak}\\
  \end{itemize}

\item[\color{Aquamarine} nota:] Esses dois XOFs acima são modelados para
resistir a colisões, e ataques à primeira e segunda pre-imagem (DRAFT FIPS 202,
pg 31, pg 23 A.1.1 Security Summary).\\

Para essas variantes acima \ref{sha3-inicial}, que foram propostas pelo
campeonato do SHA-3, o valor do parâmetros c é igual ao comprimento do resumo
multiplicado por 2. Por exemplo, o candidato SHA-3 com 512-bit de comprimento é
o Keccak com c = 1024 e r = 576 (r + c = 1600). Variantes são então, Keccak-224,
Keccak-256, e Keccak-512 (O número no final é o comprimento do resumo
criptográfico gerado por essas funções (DRAFT FIPS 202, pg 20, 21).\\

O número r de mensagem em bits processadas por bloco de permutação depende da
vazão do comprimento do resumo criptográfico. A rate r pode ser 1152, 1088, 832,
ou 576 que bate respectivamente com os tamanhos de resumos criptográficos 224,
256, 384, e 512 bits (DRAFT FIPS 202, pg 20, 21).\\

Para assegurar que a mensagem pode ser dividida corretamente em blocos de
tamanho igual a r-bits, e será enxertado (padded) com valor 1 binário, zero ou
mais bits 0 (zero) binário e ao final novamente com o valor 1 binário (por isso
que o nome da função se chama pad10star1 (DRAFT FIPS 202, pg 19).\\

Finalmente o estado (state) pode ser visualizado como um arranjo de 5x5 linhas
(lanes) onde cada linha é uma palavra de 64-bit (64-bit word). O estado inicial
de 1600-bit é totalmente preenchido com zeros (DRAFT FIPS 202, pg 17).\\

\item Responder as seguintes questões relacionadas a referência\cite{nist} que
apresenta o SHA3 padronizado pelo NIST.\\

\begin{enumerate}

\item O que é e para que serve o \textit{State Array} (figura 1)?\\

O estado para a permutação \verb|Keccak-p[b, nr]| é composta de
\textbf{\underline{b bits}}. A especificação nessa Padronização contem duas
variáveis novas relacionadas à quantidade b de bits; são elas $w = b // 25$ e
$\l = \log_2(b//25)$ \footnote{Símbolo mtm.: // significa divisão inteira.}. Os
sete possíveis valores das variáveis que são definidas para as permutações
\verb|Keccak-p| estão abaixo na tabela.

\begin{table}[ht!]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline b & 25 & 50 & 100 & 200 & 400 & 800 & 1600 \\
    \hline w & 1 & 2 & 4 & 8 & 16 & 32 & 64 \\
    \hline $\l$ & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
    \hline
  \end{tabular}
  \caption{Valores de $b,\ w,\ \l$ relacionados para a permutação KECCAK-p}
\end{table}

Esses valores são convenientes em representar os estados de entrada e saída da
permutação como strings de b-bits, e também para representar a entrada e saída
para cada mapeamento como arranjos de $5\times 5\times w$ bits. Podemos definir
$S$ agora, denotando a string de cada Mapeamento que representa o estado atual,
então, serão os bits indexados de 0 até b-1, serão portanto $b-1$ estados:

$$S=S[0]\parallel S[1]\parallel S[2]\parallel \ldots \parallel S[b-1]
\footnote{Símbolo mtm.: $\parallel$ denota a concatenação usual de string
bytes.}$$

Agora interpretando a figura 1 da página 8, temos \textbf{A} denotando o nosso
arranjo $5\times 5\times w$ de bits, e os seus índices são as 3-tuplas $(x,\ y,\
z)\ |\ 0 \le x < 5\ \textbf{e}\ 0 \le y < 5\ \textbf{e}\ 0 \le z < w$. O bit que
corresponde à coordenada $(x,\ y,\ z)$ é denotado por $A[x,\ y,\ z]$. O
\underline{arranjo estado} \footnote{Para o permutador Keccak-p, é um cubo
binário $5\times 5\times w$ dimensões.} é uma mera representação do estado em um
arranjo tri-dimensional. Cada peça da figura 1 está exposta a seguir
(Referência Keccak, sec. 1.6, pg 10, Partes do estado \cite{bertoni}):\\

\begin{enumerate}
\item estado (state) - conjunto de $5\times 5\times w$ bits
\item plano (plane) - conjunto de 25 bits (coord. y constante)
\item fatia (slice) - conjunto de 25 bits (coord. z constante)
\item folha (sheet) - conjunto de $5w$ bits (coord. x constante)
\item linha (row) - conjunto 5 bits (coord. y,z constante)
\item coluna (column) - conjunto de 5 bits (coord. x,z constante)
\item faixa (lane) - conjunto de $w$ bits (coord. x, y constante)
\item pedaço (bit) - 1 bit\\
\end{enumerate}

\item Como é feita a conversão de strings para \textit{State Arrays}? Mostrar
também um exemplo de vocês, diferente do NIST.\\

Tome $S$ como a \textbf{string} de b bits (b só pode ser 25, 50, 100, 200, 400,
800 ou 1600) que representa o estado para a permutação \verb|Keccak-p[b, nr]|.
O arranjo de estados correspondente, denotado por $A'$, é definido como segue:
$\forall\ (x,\ y,\ z)\ |\ 0 \le x < 5, 0 \le y < 5$ \textbf{e} $0 \le z < w$
\textbf{faça}:

$$\textbf{Fórmula:}\ A[x, y, z] = S[w(5y + x) + z]$$

Seja S = 0xbbbb agora precisamos setar as configurações de $b = 200;\ w = b\
//\ 25 = 8$. String: $101110111011101101000000000000\ldots000000000000000$; onde
Tamanho da String: $200 bits$ são completados com zeros.\\

$A[ 0 , 0 , 0 ]=S[8*( 0 + 0 )+ 0 ]=S[ 0 ]= 1 $\\
$A[ 0 , 0 , 1 ]=S[8*( 0 + 0 )+ 1 ]=S[ 1 ]= 0 $\\
$A[ 0 , 0 , 2 ]=S[8*( 0 + 0 )+ 2 ]=S[ 2 ]= 1 $\\
$A[ 0 , 0 , 3 ]=S[8*( 0 + 0 )+ 3 ]=S[ 3 ]= 1 $\\
$A[ 0 , 0 , 4 ]=S[8*( 0 + 0 )+ 4 ]=S[ 4 ]= 1 $\\
$A[ 0 , 0 , 5 ]=S[8*( 0 + 0 )+ 5 ]=S[ 5 ]= 0 $\\
$A[ 0 , 0 , 6 ]=S[8*( 0 + 0 )+ 6 ]=S[ 6 ]= 1 $\\
$A[ 0 , 0 , 7 ]=S[8*( 0 + 0 )+ 7 ]=S[ 7 ]= 1 $\\
$A[ 0 , 0 , 8 ]=S[8*( 0 + 0 )+ 8 ]=S[ 8 ]= 1 $\\
$A[ 0 , 0 , 9 ]=S[8*( 0 + 0 )+ 9 ]=S[ 9 ]= 0 $\\
$A[ 0 , 0 , 10 ]=S[8*( 0 + 0 )+ 10 ]=S[ 10 ]= 1 $\\
$A[ 0 , 0 , 11 ]=S[8*( 0 + 0 )+ 11 ]=S[ 11 ]= 1 $\\
$A[ 0 , 0 , 12 ]=S[8*( 0 + 0 )+ 12 ]=S[ 12 ]= 1 $\\
$A[ 0 , 0 , 13 ]=S[8*( 0 + 0 )+ 13 ]=S[ 13 ]= 0 $\\
$A[ 0 , 0 , 14 ]=S[8*( 0 + 0 )+ 14 ]=S[ 14 ]= 1 $\\
$A[ 0 , 0 , 15 ]=S[8*( 0 + 0 )+ 15 ]=S[ 15 ]= 1 $\\
$A[ 0 , 0 , 16 ]=S[8*( 0 + 0 )+ 16 ]=S[ 16 ]= 0 $\\
$A[ 0 , 0 , 17 ]=S[8*( 0 + 0 )+ 17 ]=S[ 17 ]= 1 $\\
$A[ 0 , 0 , 18 ]=S[8*( 0 + 0 )+ 18 ]=S[ 18 ]= 0 $\\
$A[ 0 , 0 , 19 ]=S[8*( 0 + 0 )+ 19 ]=S[ 19 ]= 0 $\\
$A[ 0 , 0 , 20 ]=S[8*( 0 + 0 )+ 20 ]=S[ 20 ]= 0 $\\
$A[ 0 , 0 , 21 ]=S[8*( 0 + 0 )+ 21 ]=S[ 21 ]= 0 $\\
$$\ldots$$
$A[ 3 , 2 , 0 ]=S[8*( 2 + 3 )+ 0 ]=S[ 19 ]= 0 $\\
$A[ 3 , 2 , 1 ]=S[8*( 2 + 3 )+ 1 ]=S[ 20 ]= 0 $\\
$A[ 3 , 2 , 2 ]=S[8*( 2 + 3 )+ 2 ]=S[ 21 ]= 0 $\\
$A[ 3 , 2 , 3 ]=S[8*( 2 + 3 )+ 3 ]=S[ 22 ]= 0 $\\
$A[ 3 , 2 , 4 ]=S[8*( 2 + 3 )+ 4 ]=S[ 23 ]= 0 $\\
$A[ 3 , 2 , 5 ]=S[8*( 2 + 3 )+ 5 ]=S[ 24 ]= 0 $\\
$A[ 3 , 2 , 6 ]=S[8*( 2 + 3 )+ 6 ]=S[ 25 ]= 0 $\\
$A[ 3 , 2 , 7 ]=S[8*( 2 + 3 )+ 7 ]=S[ 26 ]= 0 $\\
$A[ 3 , 2 , 8 ]=S[8*( 2 + 3 )+ 8 ]=S[ 27 ]= 0 $\\
$A[ 3 , 2 , 9 ]=S[8*( 2 + 3 )+ 9 ]=S[ 28 ]= 0 $\\
$$\ldots$$
$A[ 4 , 0 , 181 ]=S[8*( 0 + 4 )+ 181 ]=S[ 185 ]= 0 $\\
$A[ 4 , 0 , 182 ]=S[8*( 0 + 4 )+ 182 ]=S[ 186 ]= 0 $\\
$A[ 4 , 0 , 183 ]=S[8*( 0 + 4 )+ 183 ]=S[ 187 ]= 0 $\\
$A[ 4 , 0 , 184 ]=S[8*( 0 + 4 )+ 184 ]=S[ 188 ]= 0 $\\
$A[ 4 , 0 , 185 ]=S[8*( 0 + 4 )+ 185 ]=S[ 189 ]= 0 $\\
$A[ 4 , 0 , 186 ]=S[8*( 0 + 4 )+ 186 ]=S[ 190 ]= 0 $\\
$A[ 4 , 0 , 187 ]=S[8*( 0 + 4 )+ 187 ]=S[ 191 ]= 0 $\\
$A[ 4 , 0 , 188 ]=S[8*( 0 + 4 )+ 188 ]=S[ 192 ]= 0 $\\
$A[ 4 , 0 , 189 ]=S[8*( 0 + 4 )+ 189 ]=S[ 193 ]= 0 $\\
$A[ 4 , 0 , 190 ]=S[8*( 0 + 4 )+ 190 ]=S[ 194 ]= 0 $\\
$A[ 4 , 0 , 191 ]=S[8*( 0 + 4 )+ 191 ]=S[ 195 ]= 0 $\\
$A[ 4 , 0 , 192 ]=S[8*( 0 + 4 )+ 192 ]=S[ 196 ]= 0 $\\
$A[ 4 , 0 , 193 ]=S[8*( 0 + 4 )+ 193 ]=S[ 197 ]= 0 $\\
$A[ 4 , 0 , 194 ]=S[8*( 0 + 4 )+ 194 ]=S[ 198 ]= 0 $\\
$A[ 4 , 0 , 195 ]=S[8*( 0 + 4 )+ 195 ]=S[ 199 ]= 0 $\\
$A[ 4 , 0 , 196 ]=S[8*( 0 + 4 )+ 196 ]=S[ 200 ]= 0 $\\


\item Como é feita a conversão de \textit{State Array} para Strings? Incluir um
exemplo de vocês.\\

Seja \textbf{A} o state array. A string correspondente, denotada por \textbf{S},
pode ser construído pegando as Linhas (ou Trilhas) de \textbf{A}, da seguinte
forma, cada par de inteiros $(i,j)\ |\ 0 \le i < 5\ \textbf{e}\ 0 \le j < 5$
definem a string Linha(i,j) por: $Linha(i,j)=A[i,j,0] \parallel A[i,j,1]
\parallel A[i,j,2] \parallel A[i,j,0] \parallel A[i,j,w-2] \parallel
A[i,j,w-1]$. Um exemplo:\\

$Trilha (0, 0) = A[0, 0, 0] \parallel A[0, 0, 1] \parallel A[0, 0, 2] \parallel
\ldots \parallel A[0, 0, 62] \parallel A[0, 0, 63]$ corresponde a: $Trilha (0,
0) = 1 \parallel 0 \parallel 1 \parallel \ldots \parallel 0 \parallel 0$\\

$A[1, 0, 0] = [8(5*1+0)+0] = S[40] = 0$\\
$A[1, 0, 2] = [8(5*1+0)+1] = S[41] = 0$\\
$A[1, 0, 3] = [8(5*1+0)+2] = S[42] = 0$\\
$$\ldots$$
$A[1, 0, 4] = [8(5*1+0)+62] = S[102] = 0$\\
$A[1, 0, 5] = [8(5*1+0)+63] = S[103] = 0$\\

$Trilha (1, 0) = A[1, 0, 0] \parallel A[1, 0, 1] \parallel A[1, 0, 2] \parallel
\ldots \parallel A[1, 0, 62] \parallel A[1, 0, 63]$ corresponde a: $Trilha (1,
0) = 0 \parallel 0 \parallel 0 \parallel \ldots \parallel 0 \parallel 0$. E
assim sucessivamente. O que se faz é uma transformação linear $R^3 \rightarrow
R^2$ das coordenadas da dimensão do arranjo. O mesmo para fazer o contrário
\underline{String para Linha}.\\

\item Explicar os cinco Passos de Mapeamento (NIST, pg 19, 3.2 Mapeamentos de
passo). Explicar os algoritmos envolvidos e cada uma das figuras apresentadas
(figuras 3 a 6, páginas 19 até 23).\\

A maneira mais fácil de entender o $\theta$ é ver o arranjo estado em duas
dimensões (mais precisamente: $5 \times 5$). Notar que cada módulo (os cinco
passos denotados pelas letras gregas $\theta, \rho, \pi, \chi, \iota$) são
invocados pelas 24 permutações. E devem ser aplicadas nessa ordem
$\iota(\chi(\pi(\rho(\theta(\textbf{A})))))$, isto é, as funções são aplicadas
em cima da matriz $A$ de bits (arranjo de estados). Todos os algoritmos estão
explicados a seguir tem entrada $A$ e saída $A'$. Sendo que os limites das
variáveis já foram especificados anteriormente. Esses algoritmos de
transformação dos bits retornarão ao final um arranjo de estados atualizado.\\

Algoritmo $\theta(A)$ (DRAFT FIPS 202, pg 19)
%  \begin{enumerate}
%    \item[] \textbf{para} x = 0 \textbf{até} 4 \textbf{faça}
%    \item[] \quad C[x] = a[x, 0]
%    \item[] \quad \textbf{para} y = 1 até 4 \textbf{faça}
%    \item[] \quad \quad C[x] = C[x] $\oplus$ a[x, y]
%    \item[] \quad \textbf{fim para}
%    \item[] \textbf{fim para}
%    \item[] \textbf{para} x = 0 \textbf{até} 4 \textbf{faça}
%    \item[] \quad D[x] = C[x-1] $\oplus$ ROTACIONA(C[x+1], 1)
%    \item[] \quad \textbf{para} y = 0 \textbf{até} 4 \textbf{faça}
%    \item[] \quad \quad A[x,y] = a[x,y] $\oplus$ D[x]
%    \item[] \quad \textbf{fim para}
%    \item[] \textbf{fim para}\\
%  \end{enumerate}

$C[x] = A[x, 0] \oplus A[x, 1] \oplus A[x, 2] \oplus A[x, 3] \oplus A[x, 4] ,
\quad x = 0, 1, 2, 3, 4$\\ $D[x] = C[x-1] \oplus rotl(C[x + 1], 1), \qquad
\qquad  \qquad  \qquad x = 0, 1, 2, 3, 4$\\ $A[x, y] = A[x, y] \oplus D[x] ,
\qquad  \qquad  \qquad  \qquad \qquad  \qquad  \quad x, y = 0, 1, 2, 3, 4$\\

O mapeamento $\theta$ é linear e foca na \underline{difusão} e é invariante em
todas as direções. Seu efeito pode ser descrito da seguinte maneira: ele
trabalha no arranjo todo $5 \times 5 \times w$. Computa as paridades de cada
coluna e combina elas com o operador $\oplus$. Então faz $\oplus$ com as
paridades resultantes para cada bit-estado da seguinte forma: $A'[i][j][k] =
A'[i][j][k] \oplus paridade(A[0\ldots4][j-1][k]) \oplus
paridade(A[0\ldots4][j+1][k+1])\ \textbf{where}\
i=0\ldots4;j=0\ldots4;k=0\ldots(w-1)$ Então Esse algorítimo tem por efeito fazer
$\oplus$ cada bit no arranjo de estado aos seus pares de duas colunas no
arranjo. Os cálculos são feito usando limites modulares (mod 5) para não
passarem no limite do arranjo (DRAFT FIPS 202, pg 20).\\

Algoritmo $\rho(A)$ (DRAFT FIPS 202, pg 20)
  \begin{enumerate}
    \item $\forall z\ \textit{dentre}\ 0 \le z < w\ \textit{faça}\ A'[0, 0,
    z] = A[0, 0, z]$

    \item $(x, y) = (1, 0)$

    \item $\textbf{Para}\ t\ \textbf{de}\ 0\ \textbf{até}\ 23:$

    \item[] \quad $\forall z,\ \textit{dentre}\ 0 \le z < w,\
    \textit{faça}\ A'[x, y, z] = A[x, y, (z – (t + 1)(t + 2)/2)\ \textit{mod}\
    w];$

    \item[] \quad $(x, y) = (y, (2x + 3y)\ \textit{mod}\ 5);$

    \item \textbf{Retorne} $A'$.\\
  \end{enumerate}

O módulo $\rho$ rotaciona cada linha de $w-bits$  por um número triangular
$0,1,3,6,10,15$ O efeito do algoritmo acima ($\rho$) é rotacionar os bits de
cada linha pela seu $\textit{mod}\ length$, length também chamado
\textit{offset} o qual depende de x,y fixos nas coordenadas da linha (DRAFT FIPS
202, pg 20).\\

Algoritmo $\pi(A)$ (DRAFT FIPS 202, pg 21 Mapeamentos de passo)
  \begin{enumerate}
    \item $\forall (x,y,z)\ |\ 0 \le x < 5\ \textbf{e}\ 0 \le z < w:$
    \item[] \quad $y' \leftarrow (x+3y)\ \textbf{mod 5};$
    \item[] \quad $A'[x,y,z]=A[y',\ x,\ z];$
    \item \textbf{Retorne} $A'$\\
  \end{enumerate}

O módulo $\pi$ permuta os w-bits. A permutação segue o seguinte padrão:
$A[j][2\times i+3\times j][~]=A[i][j][~]$. O efeito do algoritmo acima é
rearranjar as posições das linhas. Note que y' sobre uma transformação linear e
o arranjo permuta as posições de $x,y,z \rightarrow y',x,z$ e $y'$ esta descrito
acima no algoritmo.\\

Note que ambos os passos $\rho$ e $\pi$ podem ser computados de uma só vez.
Criemos um arranjo auxiliar B (5x5) a partir do arranjo estado A. Veja que
B[i,j] é a palavra com \textbf{w-bits}.

Algoritmo $\rho \cup \pi(A)$ (DRAFT FIPS 202, pg 21 Mapeamentos de passo)\\
$B[y, 2x+3y] = rotl(A[x,y], r[x,y]),\ x,y=0,1,2,3,4$\\

Algoritmo $\chi(A)$ (DRAFT FIPS 202, pg 22 Mapeamentos de passo)
  \begin{enumerate}
    \item $\forall (x,y,z)\ |\ 0 \le x < 5, 0 \le y < 5, \textbf{e}\ 0 \le z
    < w:$

    \item[] \quad $A'[x,y,z] = A[x,y,z]\ \oplus\ ((A[(x+1)\ \textbf{mod 5},\
    y,\ z]\ \oplus\ 1) \land\ A[(x+2)\ \textbf{mod}\ 5,\ y,\ z]);$

    \item \textbf{Retorne} $A'$\\
  \end{enumerate}

Para fins de implementação fica mais fácil olhar para o algoritmo $\chi$ da
seguinte forma:
$A[x,y] = B[x,y] \oplus ((\bar{B}[x+1, y]) \land B[x+2, y]), \ x,y=0,1,2,3,4$\\

Aqui $\bar{B}[i,j]$ denota o complemento bit a bit da linha no endereço [i,j], e
$\land$ é a operação e lógico bit a bit. Em todos os passos os índices são
módulo 5. Ele pega as linhas nos endereços [x+2, y] e faz $\land$ com as linhas
nos endereços [x+1, y] e depois o resultado disso, faz $\oplus$'s com a linha no
endereço [x,y] (DRAFT FIPS 202, pg 23, Figure 6: $\chi$ aplicado a uma única
linha).\\

Algoritmo $\iota(A)$ (DRAFT FIPS 202, pg 19 Mapeamento)
  \begin{enumerate}
    \item $\forall (x,y,z)\ |\ 0 \le x < 5, 0 \le y < 5,\ and\ 0 \le z < w,\
    \textbf{faça}:$
    \item[] \quad $A'[x, y, z] = A[x, y, z]$
    \item $RC=0^{w}$
    \item $\forall j,\ 0\ \textbf{até}\ l:$
    \item[] \quad $RC[2^{j} - 1] = rc(j+7*i_{r})$
    \item $\forall z\ |\ 0 \le z < w:$
    \item[] \quad $A' [0, 0, z] = A'[0, 0, z]\ \oplus\ RC[z]$
    \item \textbf{Retorne} $A'$\\
  \end{enumerate}

Para fins de implementação fica mais fácil olhar para o algoritmo $\chi$ da
seguinte forma:\\
$A[0,0] = A[0,0] \oplus RC[i]$\\

\begin{table}
  \centering
  \begin{tabular}{|l|l|}
  \hline RC[~0] = 0x0000000000000001 & RC[12] = 0x000000008000808B \\
  \hline RC[~1] = 0x0000000000008082 & RC[13] = 0x800000000000008B \\
  \hline RC[~2] = 0x800000000000808A & RC[14] = 0x8000000000008089 \\
  \hline RC[~3] = 0x8000000080008000 & RC[15] = 0x8000000000008003 \\
  \hline RC[~4] = 0x000000000000808B & RC[16] = 0x8000000000008002 \\
  \hline RC[~5] = 0x0000000080000001 & RC[17] = 0x8000000000000080 \\
  \hline RC[~6] = 0x8000000080008081 & RC[18] = 0x000000000000800A \\
  \hline RC[~7] = 0x8000000000008009 & RC[19] = 0x800000008000000A \\
  \hline RC[~8] = 0x000000000000008A & RC[20] = 0x8000000080008081 \\
  \hline RC[~9] = 0x0000000000000088 & RC[21] = 0x8000000000008080 \\
  \hline RC[10] = 0x0000000080008009 & RC[22] = 0x0000000080000001 \\
  \hline RC[11] = 0x000000008000000A & RC[23] = 0x8000000080008008 \\
  \hline
  \end{tabular}
  \caption{Tabela das constantes, que foram usadas na implementação keccak.py
  que vem em anexo são as constantes padrões Keccak (64 bits).}
\end{table}

O módulo $\iota$ insiste em \textbf{\underline{desmembrar}} as simetrias
causadas pelos outros módulos. (Keccak Reference 3.0, Sec 2.3.5, pg 22,
Propriedades do $\iota$)\\

E como isso é feito? Isso é feito fazendo $\oplus$ de um elemento do arranjo (1
bit) com uma constante de rodada periodicamente aplicada. O módulo tem 24
constantes para escolher, que são definidas internamente pelo \verb|Keccak-f|
sem as constantes o mapeamento $\iota$ iria ser simétrico, causando
todo os mapeamentos para serem simétricos, uma das razões do $\iota$ ser o
último módulo executado é justamente para desmembrar a simetria, dando
suscetibilidade a ataques como Slide (Keccak Reference 3.0, Sec 4.1.3, Ataques
tipo Slide) \footnote{São ataques que exploram a simetria numa primitiva que
consiste da iteração de um número idêntico de rodadas. No âmbito do $\iota$.
todas as rodadas são idênticas (no sentido que elas não permutam entre sí, mas
os bits no arranjo de estados ganham anti-simetria ao decorrer das permutações).
Nesse caso, isso permite em distinguir propriedades do Keccak-f: a distribuição
do comprimento dos ciclos irá significativamente diferenciar de um estilo de
permutação do tipo fortemente aleatória}. Esse parâmetro novo aqui, dentre os
algoritmos de modulo mapeadores, chamado $i_r$ implica em $l+1$ que será
reconhecida como a constante da rodada, denotada por \underline{RC}. Cada valor
gerado por $l+1$ surge da função baseada em um modo de operação chamado
retroalimentação linear de registrador deslocamento (linear feedback shift
register) essa função é chamada de rc (DRAFT FIPS 202, pg 23, $rc(t)$), note que
no passo 2 (ii) temos a concatenação $w$ de zeros.\\

O efeito do algoritmo acima (iota) é modificar alguns bits da Linha(0, 0) da
maneira que fica dependente do índice $i_r$ (i rodadas). As outras 24 linhas não
são afetadas pelo algoritmo iota. Além da entrada ser o state array \textbf{A},
também temos \textit{round index} $i_r$.\\

\item Explicar a permutação \verb|Keccak-p[b, n]|.\\

O \textit{Keccak-p} contém um tamanho fixo de string que serão permutadas,
chamado de espessura da permutação, e também o número de iterações da
transformação (rodada) interna. A espessura é o $b$ e o número de rodadas
(transformações internas) é $n_r$.\\

Dado um arranjo de estados $A$ e também um índice $i_r$ então a função de rodada
Rodada \footnote{Rodada ou ''Rnd'' ou ''Round'' é uma função da permutação
\textsc{KECCAK-p}, no código em Python3, que vem em anexo ao artigo, essa função
se chama \textit{Round}. Esse código está disponível em:
\href{http://keccak.noekeon.org/}{http://keccak.noekeon.org/}} é uma
transformação que resulta da aplicação dos Passos de Mapeamento $\theta,\ \rho,\
\pi,\ \chi,\ \iota$ nessa mesma ordem, isto é: $Rnd(A, i_r) =
\iota(\chi(\pi(\rho(\theta(A)))), i_r)$.\\

A permutação \verb|KECCAK-p[b, n]| consiste de $n_r$ iterações do procedimento
$Rnd$, como especificado no Algoritmo 7, \verb|KECCAK-p[b, n](S)|.\\

  \begin{enumerate}
    \item \textbf{Entrada}: Uma mensagem $S$ de tamanho $b$; Número de rodadas
    $n_r$.
    \item \textbf{Saída}: Uma mensagem $S'$ de tamanho $b$.
    \item \textbf{Converter} $S$ em Arranjo de Estados $A$, como descrito na
    Sec. 3.1.2
    \cite{nist}.
    \item $l \leftarrow len(S)$
    \item \textbf{Para} $i_r$ de $(2l + 12 - n_r)\ \textbf{até}\ (2l + 12 - 1):$
    \item[] \quad $A \leftarrow Rnd(A,\ i_r)$.
    \item \textbf{Converter} $A$ na \textbf{string} $S'$ de tamanho $b$, como
    descrito na (DRAFT FIPS 202, sec. 3.1.3 \cite{nist})
    \item \textbf{Retornar} $S'$.\\
  \end{enumerate}

\begin{enumerate}

  \item Compare esta função com a \verb|Keccak-f|.\\

      Keccak é uma família de funções hash baseadas na construção esponja. A
      esponja pode ser visualizada como uma matriz de tri dimensional
      $\textbf{A} = a(x,y,z)_{5x5xw}$ Que também eh conhecida como 'estado' ou
      em (inglês.: 'state'), a qual é entrada para as fases "inchamento" (A
      entrada $\oplus$-ring é parte do estado) e "espremida" da esponja faz o
      papel de processar as saídas do hash O Keccak usa uma função chamada
      Keccak-f[b] que atua no 'estado' todo onde b pertence a {25, 50, 100, 200,
      400, 800, 1600} O padrão oficial usa w = 64 como numero de entradas
      binarias na linha que significa a profundidade do arranjo estado, ou
      simplesmente estado (inglês.: \textit{state array}). Exemplo: $5\times
      5\times 65 = 1600$, isto é, $b = 1600$. Uma string s de $5\times 5\times
      w$ bits vai ser mapeada para b bits do 'matriz estados' (= arranjo estado)
      da seguinte maneira s[w(5*y+x)+z] = a[x][y][z]. E $b$, bits contíguos, no
      estado podem ser divididos entre a "parte exterior" (os primeiros r bits)
      e a "parte interior" ou a "capacidade" 'c' (inglês.: \textit{capacity})
      consistindo de c = b - r bits ou c + r = b bits. 'c' eh escolhido para ser
      2N onde N eh o tamanho da vazão que vai ser gerada pelo algoritmo.
      \cite{rosie14, keccak}\\

      O SHA3 utiliza \verb|Keccak-p[1600, 24]| (1600 bits, 24 permutações), é
      equivalente a simplesmente \verb|Keccak-f[1600]|. As rodadas do
      \verb|Keccak-f[b]| são indexadas de 0 até $(11 + 2\l)$. O resultado é
      indexado dentro do Passo 2 | Algoritmo 7 pois a rodada do
      \verb|Keccak-p[b, n]| bate com a última rodada do \verb|Keccak-f[b]|, e
      vice versa.\\

      Por exemplo, \verb|Keccak-p[1600, 19]| (1600 bits, 19 permutações) é
      equivalente a última rodada de número 19 do \verb|Keccak-f[1600]|.
      Similarmente, \verb|Keccak-f[1600]| é equivalente para com a 24ª rodada do
      \verb|Keccak-p[1600, 30]| (1600 bits, 30 permutações); mas nesse caso, as
      rodadas precedentes para \verb|Keccak-p[1600, 30]| são indexadas de -6 à
      -1 (DRAFT FIPS 202, sec. 3.4, pg 25).\\

\end{enumerate}

\item Descrever o \textit{Framework Sponge Construction}.\\

A construção esponja para funções de hash. pi são blocos da string de entrada,
zi são blocos do hash de saída. (DRAFT FIPS 202, Figure 7: The sponge
construction). A construção \verb|[f, pad, r]| com entrada sendo o comprimento,
A "esponja"\ é uma função que lembra as "Redes de Feistel". A saída é arbitrária
e se dá a partir de permutações de tamanho fixado pela norma SHA3 e constrói a
função esponja a partir da permutação $f$, o a regra de padding "pad" e o
parâmetro bitrate $r$ \cite{bertoni}.\\

\begin{table}[ht!]
\centering
\label{sha3tablepar}
\begin{tabular}{|l|l|l|l|l|}
\hline Tam. digest & 224 & 256 & 384 & 512 \\
\hline Tam. mensagem & $\infty$ & $\infty$ & $\infty$ & $\infty$ \\
\hline Tam. bloco (bitrate r) & 1152 & 1088 & 832 & 576 \\
\hline Tam. palavra & 64 & 64 & 64 & 64 \\
\hline Nro de rodadas & 24 & 24 & 24 & 24 \\
\hline Cap. c & 448 & 512 & 768 & 1024 \\
\hline Resis. colisões & $2^{112}$ & $2^{118}$ & $2^{192}$ & $2^{256}$ \\
\hline Resis. 2ª pre-imagem & $2^{224}$ & $2^{256}$ & $2^{384}$ & $2^{512}$ \\
\hline
\end{tabular}
\caption{Parâmetros SHA-3, Todas as medições estão em bits. Atente para as duas
últimas linhas, pois as demais são para se habituar para a solução da construção
esponja. Essa tabela mostra que essa função esponja tem as resistências dadas em
quantidades de entradas que se tem que gerar para cair no caso do paradoxo do
aniversário, e possivelmente ficar sujeito aos ataques vistos no começo do
artigo \ref{tiposataque}. Todos esses valores nas últimas duas linhas são
intratáveis computacionalmente.}
\end{table}

  \begin{enumerate}
    \item Explique a figura 7 e o Algoritmo 8.\\

    A figura 7 representa a seguite construção em forma paramétrica
    \cite{gbertoni}: $$Z = ESPONJA[f, pad, r](M, d)$$ que consiste em colocar
    ''pad'' e ''inchar'' o conteúdo fazendo $\oplus's$ do \underline{padding}
    com os $r$ bits menos significativos. $r$ é o valor de rate, ou bitrate.\\

    A analogia com esponja é porque a função ''absorve'' um número arbitrário
    da entrada (em bits) nos seu ''estado''.


  \end{enumerate}

\item Explique a família de funções esponja Keccak, conforme seção 5.\\

Keccak é a família de "funções esponja" \cite{bertoni}. Uma característica dela
é \underline{padding rule} (regra de preenchimento) chamada \textit{multi-rate
padding} (preenchimento multi-frequência, explicado melhor nessa seção). Os
parâmetros e as permutações intrínsecas para a família Keccak são descrições
nessa seção também, e o conjunto de famílias da menor a maior ajudam a definir
suficientemente as funções do SHA-3 na próxima seção.\\

A regra de preenchimento multi-frequência, denotada por $pad1(0^{*})1$, é
especificada no Algoritmo 9 (DRAFT FIPS 202, pg 27, $pad1(0^{*})1(x,m)$).\\

Algorithm pad10*1(x, m) (DRAFT FIPS 202, pg 27)

  \begin{enumerate}
    \item \textbf{Entrada:} Inteiro Positivos x, m
    \item \textbf{Saída:} String Z, onde $m+len(Z)$ é positivo e múltiplo de x.
    \item $j \leftarrow -(m+2)\ mod\ x$
    \item \textbf{Retorne} $1\ ||\ 0^{j}\ ||\ 1$\\
  \end{enumerate}

Para assegurar que a mensagem pode ser dividida corretamente em blocos de
tamanho igual a r-bits, e será enxertado (padded) com valor 1 binário, zero ou
mais bits 0 (zero) binário e ao final novamente com o valor 1 binário (por isso
que o nome da função se chama pad10star1.\\

A família de funções esponjas Keccak é então a soma da função de permutação
intrínseca padrão $KECCAK-p[b, 12 + 2\times \l]$ (DRAFT FIPS 202, Sec 3.3) mais
a regra de preenchimento $pad10^{*}1$ (DRAFT FIPS 202, Sec 5.1).


    $$b=1600$$
    $$w = b\ //\ 25 = 64$$
    $$\l = int(log_2(w)) = 6$$
    $$n_r = 12 + 2 \times \l = 12 + 2\times 6 = 24\ \textit{permutações}$$


A família é parametrizada por qualquer escolha de rate $r$ e de capacidade $c$
(define o nível de segurança) da qual $r+c$ pertence ao conjunto de
possibilidades {25, 50, 100, 200, 400, 800, 1600}. Nós obtemos a função esponja
\verb|Keccak[r,c]|, com parâmetros de capacidade $c$ e bitrate (ou apenas rate)
$r$ (define a velocidade), se nós aplicarmos isso na função esponja
\verb|Keccak-f[r+c]| e também aplicando juntamento um preenchimento (padding)
específico à mensagem de entrada.\\

Quando restringimos ao caso b=1600, a família Keccak é denotada simplesmente
por Keccak[c]; nesse caso $r$ é determinado pela escolha de $c$. Reusando a
própria função veja (DRAFT FIPS 202, pg 27).\\

KECCAK[c] = [KECCAK-p[1600, 24], pad10*1, 1600 - c]\\

Assim, dado uma mensagem $M$ e uma saída de tamanho $d$. Aplicamos $M$ da
seguinte forma na função esponja.\\

KECCAK[c](M, d) = [KECCAK-p[1600, 24], pad10*1, 1600 – c](M,
d)\\

\item Explique as especificações da função SHA3, conforme Seção 6.\\

O corpo SHA-3 contém 4 funções \underline{hash}, e 2 XOFs \ref{sha3-inicial}.
Explicarei cada uma delas a seguir nos itens abaixo.\\

\begin{enumerate}

\item Funções de hash SHA3.\\

Antes de mais nada deve-se entender que o SHA3 também utiliza $M$ para Mensagem.
porém ele adiciona 2 bits (ou 4 bits) concatenados à $M$ em \underline{todas}
das funções hash (DRAFT FIPS 202, Sec 5.2, pg 28). Nesse caso são 2 bits, como
está previsto no documento na seção 6.1, $b_{0}b_{1}$ são os bits a serem
concatenados, mais descrições deles adiante.\\

Na seção 6.2 como podemos ver que o SHA3-224(M) utiliza o
Keccak[448]. Com capacidade $c$ de 448 bits. E assim sucessivamente, aumentando
as capacidade para 512, 767, 1024. E é exatamente isso que é passado para a
função esponja Keccak.\\

$SHA3_{224}(M) = f[448](M || b_{0}b_{1},\ 224)$\\

$SHA3_{256}(M) = f[512](M || b_{0}b_{1},\ 256)$\\

$SHA3_{384}(M) = f[768](M || b_{0}b_{1},\ 384)$\\

$SHA3_{512}(M) = f[1024](M || b_{0}b_{1},\ 512)$\\

Note que $f$ é a função esponja Keccak. Em cada caso, a capacidade é dobrada em
tamanho consecutivamente \underline{\textbf{dobra}} o tamanho (comprimento) da
resumo pós ''trituração'' (STALLINGS, Sec 11.1, pg 314 - Funções de Trituração
Criptográficas), isto é: $c = 2*d$. Os dois bits que são concatenados à mensagem
(i.e, 01) suportam o \textit{domain separation}; eles distinguem a mensagem para
o SHA3. Para assegurar que a mensagem pode ser dividida em blocos pares de
tamanho $r$ (bitrate) a regra do padding é aplicada ou seja, o padrão
"bit-a-bit" $pad10^{*}1$: bit 1, zero ou mais 0's (máximo de r - 1), 1 bit.\\

\begin{table}[ht!]
  \label{sha3par}
  \centering
  \begin{tabular}{|c|c|c|c|}
    \hline Função & Rate [r] & Capacidade [c] & Vazão [n] \\
    \hline SHA3-224 & 1152 & 448 & 224 \\
    \hline SHA3-256 & 1088 & 512 & 256 \\
    \hline SHA3-384 & 832 & 768 & 384 \\
    \hline SHA3-512 & 576 & 1024 & 512 \\
    \hline SHAKE128 & 1344 & 256 & d \\
    \hline SHAKE256 & 1088 & 512 & d \\
    \hline
  \end{tabular}
  \caption{Tabela de parâmetros para a família SHA-3 (Keccak), note que r + c dá
  1600 em todos os casos. Para os casos do SHAKE-n, temos que a vazão é
  entendida para fazer muito mais que as normais dentre 224 à 512. Isto é por
  que dependendo da aplicação pode ser necessário. Esses são os mesmos valores
  usando no código keccak.py que acompanha esse artigo.}
\end{table}

Isso é preciso pois está na norma da construção da esponja Keccak, a prova de
conceito para o resumo criptográfico usando Keccak existe que a taxa seja
codificada dessa maneira no bloco final ("multi rate padding"). O último DRAFT
FIPS 202 coloca os bits de concatenação para as funções de resumo criptográfico
SHA3 como sendo $b_{0},\ b_{1} = (0,\ 1)$. Isso provê \textit{domain separation}
para os SHAKEs (SHA3+Keccak)\footnote{Separação de domínio é uma maneira de
separar informação dentro de domínios logicamente definidos}. A seguir estão
explicadas as funções SHAKE's.\\

\item Funções de Saída (Vazão) Estendida.\\

As duas SHA3 XOFs \ref{sha3-inicial}, SHAKE128 e SHAKE256, são definidas de duas
funções intermediárias (descritas abaixo), chamas RawSHAKE128 e RawSHAKE256, o
qual são definidas a partir de? Keccak[c=capacity]) (DRAFT FIPS 202, Sec 5.2).\\

RawSHAKE128(M, d) = KECCAK[256](M $||$ $b_{0}b_{1}$, d)\\

RawSHAKE256(M, d) = KECCAK[512](M $||$ $b_{0}b_{1}$, d)\\

Os dois bits que são concatenados à mensagem, isto é.; $b_{0}b_{1}=11$ (DRAFT
FIPS 202, pg 28), suportam \textit{domain separation}. As duas XOFs são (só
muda o nome de RawSHAKE128 para SHAKE128) e RawSHAKE256 para SHAKE256):\\

Nesse caso, os bits 11 são concatenados à mensagem para compatibilidade com o
esquema de codificação \underline{Sakura}. O Sakura-scheme é um hash distribuído
em estrutura de árvore (grafo de nós direcional)\cite{sakura}. Esse esquema
flexibiliza o desenvolvimento dos XOFs. Além disso, possibilita a computação de
forma paralela, permitindo computar, atualizar resumos criptográficos de
mensagens longas com mais eficiência. As funções de vazão-estendida tem o sufixo
que permite compatibilidade com o esquema Sakura de árvores hash. Para SHA3-n, o
FIPS 202 configura $c = 2n$, assim quem estivesse implementando precisaria criar
um complemento em cima dessa equação para ter 2 blocos de saída (como uma
máscara), e isso iria ser penoso dado que o SHA3-n obtém seus resultados
truncando a saída do Keccak. As funções de vazão-estendida são definidas em
dois passos \cite{sakura}:\\

$SHAKE128(M, d) = RawSHAKE128(M || 11, d)$\\

$SHAKE256(M, d) = RawSHAKE256(M || 11, d)$\\

Os dois XOF's SHA-3 podem também ser definidos diretamente a partir do Keccak,
da seguinte maneira no código \verb|keccak/keccak.py| as funções SHAKE recebem
suas \textbf{mensagens} + {\color{Red} \verb|'F'|} para satisfazer a
implementação:\\

$SHAKE128(M, d) = KECCAK[256] (M || 1111, d)$\\

$SHAKE256(M, d) = KECCAK[512] (M || 1111, d)$\\

\end{enumerate}

\item Apresente a análise de segurança conforme Apêndice A.1.\\

\begin{table}[ht!]
  \centering
  \begin{tabular}[c]{@{}|r|r|r|r|r|@{}}
    \hline
    Function & Largura de Saída & Colisão & Pré Imagem & 2ª Pré Imagem \\\hline
    SHA-1 & 160 & \textless{} 80 & 160 & 160-L(M) \\\hline
    SHA-224 & 224 & 112 & 224 & Min(224, 256-L(M)) \\\hline
    SHA-512/224 & 224 & 112 & 224 & 224 \\\hline
    SHA-256 & 256 & 128 & 256 & 256-L(M) \\\hline
    SHA-512/256 & 256 & 128 & 256 & 256 \\\hline
    SHA-384 & 384 & 192 & 384 & 384 \\\hline
    SHA-512 & 512 & 256 & 512 & 512-L(M) \\\hline
    SHA3-224 & 224 & 112 & 224 & 224 \\\hline
    SHA3-256 & 256 & 128 & 256 & 256 \\\hline
    SHA3-384 & 384 & 192 & 384 & 384 \\\hline
    SHA3-512 & 512 & 256 & 512 & 512 \\\hline
    SHAKE128 & d & min(d/2, 128) & \textgreater{}= min(d, 128) &
    \textgreater{}= min(d, 128) \\\hline
    SHAKE256 & d & min(d/2, 256) & \textgreater{}= min(d, 256) &
    \textgreater{}= min(d, 256) \\\hline
  \end{tabular}
  \caption{Comparativa de Colisão, Pré Imagem e Segunda Pré Imagem em Função
  de quantos bits na Largura de Saída para cada implementação das famílias
  $SHA-n$ listadas nessa tabela. Porém vale notar, usando a tabela de parâmetros
  de cada implementação \ref{sha3par} podemos ver que implicitamente existe a
  capacidade (c) de cada implementação. {\bfseries O nível de segurança denota o
  número de computações que um atacante terá que realizar em ordem de quebrar a
  função as funções de resumo p.e.: o nível de segurança para 128 bits implica
  que o adversário deverá realizar $2^{128}$ computações.}}
\end{table}

Vou continuar a partir da explicação no começo desse trabalho, pois no apêndice
A.1.1 tem muita recapitulação sobre as definições das propriedades de colisão,
pré imagem e segunda pré imagem (Página 1, Propriedades \ref{tiposataque}). A
primeira coluna da tabela 3 (pg 22) mostra as famílias de hash criptográfico, e
colisão, pré imagem, segunda pré imagem em função da vazão (\textit{output
size}). Tanto SHA-1, SHA-2 e SHA-3 utilizam funções primitivas simples do tipo
(+, and, or, xor, rotl, rotr, etc). A vazão crescer de cima quer dizer que está
ligada a tecnologia de software, à implementação e o modelo que descreve
matematicamente a evolução dos algoritmos. O SHA-1 apresenta $\le 2^{80}$ hash's
calculados para haver colisão, quer dizer que o SHA-1 está em ritmo de
decadência quanto a sua força de resistência a colisões. O SHA-1 tem também um
número exorbitante de $2^{160}$ para quebrar a resistência a pré imagem, e
$2^{160}-Length(M)$ para segunda pré imagem. Suponha que a Mensagem tenha um
comprimento de 1024 caracteres. Então $2^{160} - 1024$ tentativas para quebrar
segunda pré imagem do SHA-1. Agora comparando o SHA-1 em relação ao SHA-224,
SHA-512/224 \footnote{SHA 512 tem 224 bits de output size pois o construção do
SHA-512 trunca os 288 bits.}, SHA-256, SHA-512/256 \footnote{SHA 512 tem 224
bits de output size pois o construção do SHA-512 trunca os 256 bits.}, SHA-384,
SHA-512 e observando que a coluna de cima para baixo lista as funções de resumo
criptográfico crescendo em complexidade e resistência. Você poderá ver com
os dados abaixo das comparações de resistências, que da família SHA-1 para
SHA-2 houve melhoria de resistência em todos.\\

\begin{enumerate}
\item SHA-224/SHA-1:
 \begin{itemize}
 \item Colisão: 1.4x mais resistente (40\%+)

 \item Preimage: 1.4x mais resistente (40\%+)

 \item 2nd Preimage: 1.6x mais resistente (40\%+)
 \end{itemize}
\item SHA-512/224/SHA-1:
 \begin{itemize}
 \item Colisão: 1.4x mais resistente (40\%+)

 \item Preimage: 1.4x mais resistente (40\%+)

 \item 2nd Preimage: 1.4x mais resistente (40\%+)
 \end{itemize}
\item SHA-256/SHA-1:
 \begin{itemize}
 \item Colisão: 1.6x mais resistente (60\%+)

 \item Preimage: 1.6x mais resistente (60\%+)

 \item 2nd Preimage: 1.6x mais resistente (60\%+)
 \end{itemize}
\item SHA-512/256/SHA-1:
 \begin{itemize}
 \item Colisão: 1.6x mais resistente (60\%+)

 \item Preimage: 1.6x mais resistente (60\%+)

 \item 2nd Preimage: 1.6x mais resistente (60\%+)
 \end{itemize}
\item SHA-384/SHA-1:
 \begin{itemize}
 \item Colisão: 2.4x mais resistente (140\%+)

 \item Preimage: 2.4x mais resistente (140\%+)

 \item 2nd Preimage: 2.4x mais resistente (140\%+)
 \end{itemize}
\item SHA-512/SHA-1:
 \begin{itemize}
 \item Colisão: 3.2x mais resistente (220\%+)

 \item Preimage: 3.2x mais resistente (220\%+)

 \item 2nd Preimage: 3.2x mais resistente (220\%+) \\
 \end{itemize}
\end{enumerate}

Agora comparando também cada elemento da família SHA-3 com todos os da SHA-2, em
colisão, pré imagem, segunda pré imagem. E configurando $d = 512\ bits$, pois a
tabela permite $d$ variável para SHAKE128\footnote{Veja que d é variável, pois
XOFs é permitido setar a vazão de saída, dependendo a aplicação dos XOFS SHA-3.}
e SHAKE256, e também usando min(d/2, 128) para o SHAKE128, e $\min(d/2, 128)$
para o SHAKE256 respectivamente e assim sucessivamente para pré imagem e depois
para segunda pré imagem. Veja que $\min(~)$ da o pior caso no sentido de
resistência às três propriedades citadas na tabela 5. Finalmente, analisando os
dados abaixo, podemos ver que alguns diminuíram suas resistência, e outros
aumentaram bem pouco como é o caso do SHA-3 comparado ao SHA-224 com aumentos de
colisões 14\%, pré imagem 14\%, e segunda pré imagem 0\% (não aumentou nada a
resistência), isso é por causa da barreira computacional, precisa melhorar a
tecnologia e o modelo matemático necessita ser ainda mais complexo e também bem
formulado para aumentar as resistências da tabela 5.\footnote{Para os casos onde
matematicamente temos $2^{n} - length(M)$ eu considerei length(M) = 0, para
facilitar nos cálculos, isso não altera na análise pois digamos que eu compare
$\frac{SHA3-512}{SHA-256}$ você pode ver todos as resistências melhoraram 2x
mais, a conta seria $\frac{SHA3-512}{SHA-256} - \frac{SHA3-512}{length(M)}$,
para length(M) > 0 e quanto maior o texto menor o valor, porém ele está
dividindo um número grande $2^{512}$ pois o caso é apenas para segunda pré
imagem que tem esse detalhe a mais na tabela.} \\

\begin{enumerate}
\item SHA3-224/SHA-224:
 \begin{itemize}
 \item Colisão: 1.0x mais resistente

 \item Preimage: 1.0x mais resistente

 \item 2nd Preimage: 1.0x mais resistente
 \end{itemize}
\item SHA3-256/SHA-224:
 \begin{itemize}
 \item Colisão: 1.1428571428571428x mais resistente (14\%+)

 \item Preimage: 1.1428571428571428x mais resistente (14\%+)

 \item 2nd Preimage: 1.1428571428571428x mais resistente (14\%+)
 \end{itemize}
\item SHA3-384/SHA-224:
 \begin{itemize}
 \item Colisão: 1.7142857142857142x mais resistente (71\%+)

 \item Preimage: 1.7142857142857142x mais resistente (71\%+)

 \item 2nd Preimage: 1.7142857142857142x mais resistente (71\%+)
 \end{itemize}
\item SHA3-512/SHA-224:
 \begin{itemize}
 \item Colisão: 2.2857142857142856x mais resistente (128\%+)

 \item Preimage: 2.2857142857142856x mais resistente (128\%+)

 \item 2nd Preimage: 2.2857142857142856x mais resistente (128\%+)
 \end{itemize}
\item SHAKE128/SHA-224:
 \begin{itemize}
 \item Colisão: 1.1428571428571428x mais resistente (14\%+)

 \item Preimage: 0.5714285714285714x \underline{menos} resistente (42\%-)

 \item 2nd Preimage: 0.5714285714285714x \underline{menos} resistente (42\%-)
 \end{itemize}
\item SHAKE256/SHA-224:
 \begin{itemize}
 \item Colisão: 2.2857142857142856x mais resistente

 \item Preimage: 1.1428571428571428x mais resistente

 \item 2nd Preimage: 1.1428571428571428x mais resistente
 \end{itemize}
\item SHA3-224/SHA-512/224:
 \begin{itemize}
 \item Colisão: 1.0x mais resistente

 \item Preimage: 1.0x mais resistente

 \item 2nd Preimage: 1.0x mais resistente
 \end{itemize}
\item SHA3-256/SHA-512/224:
 \begin{itemize}
 \item Colisão: 1.1428571428571428x mais resistente

 \item Preimage: 1.1428571428571428x mais resistente

 \item 2nd Preimage: 1.1428571428571428x mais resistente
 \end{itemize}
\item SHA3-384/SHA-512/224:
 \begin{itemize}
 \item Colisão: 1.7142857142857142x mais resistente

 \item Preimage: 1.7142857142857142x mais resistente

 \item 2nd Preimage: 1.7142857142857142x mais resistente
 \end{itemize}
\item SHA3-512/SHA-512/224:
 \begin{itemize}
 \item Colisão: 2.2857142857142856x mais resistente

 \item Preimage: 2.2857142857142856x mais resistente

 \item 2nd Preimage: 2.2857142857142856x mais resistente
 \end{itemize}
\item SHAKE128/SHA-512/224:
 \begin{itemize}
 \item Colisão: 1.1428571428571428x mais resistente

 \item Preimage: 0.5714285714285714x mais resistente

 \item 2nd Preimage: 0.5714285714285714x mais resistente
 \end{itemize}
\item SHAKE256/SHA-512/224:
 \begin{itemize}
 \item Colisão: 2.2857142857142856x mais resistente

 \item Preimage: 1.1428571428571428x mais resistente

 \item 2nd Preimage: 1.1428571428571428x mais resistente
 \end{itemize}
\item SHA3-224/SHA-256:
 \begin{itemize}
 \item Colisão: 0.875x mais resistente

 \item Preimage: 0.875x mais resistente

 \item 2nd Preimage: 0.875x mais resistente
 \end{itemize}
\item SHA3-256/SHA-256:
 \begin{itemize}
 \item Colisão: 1.0x mais resistente

 \item Preimage: 1.0x mais resistente

 \item 2nd Preimage: 1.0x mais resistente
 \end{itemize}
\item SHA3-384/SHA-256:
 \begin{itemize}
 \item Colisão: 1.5x mais resistente

 \item Preimage: 1.5x mais resistente

 \item 2nd Preimage: 1.5x mais resistente
 \end{itemize}
\item SHA3-512/SHA-256:
 \begin{itemize}
 \item Colisão: 2.0x mais resistente

 \item Preimage: 2.0x mais resistente

 \item 2nd Preimage: 2.0x mais resistente
 \end{itemize}
\item SHAKE128/SHA-256:
 \begin{itemize}
 \item Colisão: 1.0x mais resistente

 \item Preimage: 0.5x mais resistente

 \item 2nd Preimage: 0.5x mais resistente
 \end{itemize}
\item SHAKE256/SHA-256:
 \begin{itemize}
 \item Colisão: 2.0x mais resistente

 \item Preimage: 1.0x mais resistente

 \item 2nd Preimage: 1.0x mais resistente
 \end{itemize}
\item SHA3-224/SHA-512/256:
 \begin{itemize}
 \item Colisão: 0.875x mais resistente

 \item Preimage: 0.875x mais resistente

 \item 2nd Preimage: 0.875x mais resistente
 \end{itemize}
\item SHA3-256/SHA-512/256:
 \begin{itemize}
 \item Colisão: 1.0x mais resistente

 \item Preimage: 1.0x mais resistente

 \item 2nd Preimage: 1.0x mais resistente
 \end{itemize}
\item SHA3-384/SHA-512/256:
 \begin{itemize}
 \item Colisão: 1.5x mais resistente

 \item Preimage: 1.5x mais resistente

 \item 2nd Preimage: 1.5x mais resistente
 \end{itemize}
\item SHA3-512/SHA-512/256:
 \begin{itemize}
 \item Colisão: 2.0x mais resistente

 \item Preimage: 2.0x mais resistente

 \item 2nd Preimage: 2.0x mais resistente
 \end{itemize}
\item SHAKE128/SHA-512/256:
 \begin{itemize}
 \item Colisão: 1.0x mais resistente

 \item Preimage: 0.5x mais resistente

 \item 2nd Preimage: 0.5x mais resistente
 \end{itemize}
\item SHAKE256/SHA-512/256:
 \begin{itemize}
 \item Colisão: 2.0x mais resistente

 \item Preimage: 1.0x mais resistente

 \item 2nd Preimage: 1.0x mais resistente
 \end{itemize}
\item SHA3-224/SHA-384:
 \begin{itemize}
 \item Colisão: 0.5833333333333334x mais resistente

 \item Preimage: 0.5833333333333334x mais resistente

 \item 2nd Preimage: 0.5833333333333334x mais resistente
 \end{itemize}
\item SHA3-256/SHA-384:
 \begin{itemize}
 \item Colisão: 0.6666666666666666x mais resistente

 \item Preimage: 0.6666666666666666x mais resistente

 \item 2nd Preimage: 0.6666666666666666x mais resistente
 \end{itemize}
\item SHA3-384/SHA-384:
 \begin{itemize}
 \item Colisão: 1.0x mais resistente

 \item Preimage: 1.0x mais resistente

 \item 2nd Preimage: 1.0x mais resistente
 \end{itemize}
\item SHA3-512/SHA-384:
 \begin{itemize}
 \item Colisão: 1.3333333333333333x mais resistente

 \item Preimage: 1.3333333333333333x mais resistente

 \item 2nd Preimage: 1.3333333333333333x mais resistente
 \end{itemize}
\item SHAKE128/SHA-384:
 \begin{itemize}
 \item Colisão: 0.6666666666666666x mais resistente

 \item Preimage: 0.3333333333333333x mais resistente

 \item 2nd Preimage: 0.3333333333333333x mais resistente
 \end{itemize}
\item SHAKE256/SHA-384:
 \begin{itemize}
 \item Colisão: 1.3333333333333333x mais resistente

 \item Preimage: 0.6666666666666666x mais resistente

 \item 2nd Preimage: 0.6666666666666666x mais resistente
 \end{itemize}
\item SHA3-224/SHA-512:
 \begin{itemize}
 \item Colisão: 0.4375x mais resistente

 \item Preimage: 0.4375x mais resistente

 \item 2nd Preimage: 0.4375x mais resistente
 \end{itemize}
\item SHA3-256/SHA-512:
 \begin{itemize}
 \item Colisão: 0.5x mais resistente

 \item Preimage: 0.5x mais resistente

 \item 2nd Preimage: 0.5x mais resistente
 \end{itemize}
\item SHA3-384/SHA-512:
 \begin{itemize}
 \item Colisão: 0.75x mais resistente

 \item Preimage: 0.75x mais resistente

 \item 2nd Preimage: 0.75x mais resistente
 \end{itemize}
\item SHA3-512/SHA-512:
 \begin{itemize}
 \item Colisão: 1.0x mais resistente

 \item Preimage: 1.0x mais resistente

 \item 2nd Preimage: 1.0x mais resistente
 \end{itemize}
\item SHAKE128/SHA-512:
 \begin{itemize}
 \item Colisão: 0.5x mais resistente

 \item Preimage: 0.25x mais resistente

 \item 2nd Preimage: 0.25x mais resistente
 \end{itemize}
\item SHAKE256/SHA-512:
 \begin{itemize}
 \item Colisão: 1.0x mais resistente

 \item Preimage: 0.5x mais resistente

 \item 2nd Preimage: 0.5x mais resistente\\
 \end{itemize}
\end{enumerate}

\item Gere os seus próprios exemplos (diferente do NIST) conforme Apêndice
A.2.\\

\begin{verbatim}
Mensagem (para testar todos os digests sha3: fifo

Comparar com www.di-mgt.com.au/sha_testvectors.html
Gerando a função Keccak com (r=1152, c=448 (i.e. w=64))

String pronta para ser absorvida: 6669666f06000000 0000000000000000
0000000000000000 0000000000000000 0000000000000000 0000000000000000
0000000000000000 0000000000000000 0000000000000000 0000000000000000
0000000000000000 0000000000000000 0000000000000000 0000000000000000
0000000000000000 0000000000000000 0000000000000000 0000000000000080
(será completada com 56 x '00')

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois de theta ['0xcdeccd2cc', '0xcdeccd2cc', '0xcdeccd2cc', '0xcdeccd2cc',
'0xcdeccd2cc']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0x337b334b30000', '0x0',
'0x0', '0x80000000000000', '0x19bd99a59c']
Antes do modulo chi ['0xcdeccd2cc', '0xcdeccd2cc', '0xcdeccd2cc',
'0xcdeccd2cc', '0xcdeccd2cc']
Depois do modulo chi ['0x669547b334b30690', '0xcdeccd24c00000', '0x0',
'0x80000000000000', '0x400019bd99a59c']
Antes do modulo iota ['0x66f666966', '0x8000000', '0xcdfccd2ce',
'0x66f67f2bf9a59c00', '0x662966000000066f']
Depois do modulo iota ['0x66f666967', '0x8000000', '0xcdfccd2ce',
'0x66f67f2bf9a59c00', '0x662966000000066f']
Valor atual do State Array  após a rodada 1/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0x669547b334b30690', '0xcdeccd24c00000',
'0x0', '0x80000000000000', '0x400019bd99a59c']
Depois de theta ['0xcc71ffb187e7bf58', '0xaa2954cf9794b9c8',
'0xaae4b802b354b9c8', '0xaa64b802b354b9c8', '0xaaa4b81b0ecd1c54']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0x2e06c3b347152aa9',
'0x137d605147e1ce0c', '0xb501b7bbad595b7c', '0xebabdb1ed84a4a79',
'0x352e243d88c57883']
Antes do modulo chi ['0xcc71ffb187e7bf58', '0xaa2954cf9794b9c8',
'0xaae4b802b354b9c8', '0xaa64b802b354b9c8', '0xaaa4b81b0ecd1c54']
Depois do modulo chi ['0x270e43bbef410a08', '0x1f95781243e3cc1c',
'0x9581b35b8ceddf2e', '0xb96b191fd14e7a7b', '0x35bd0f0ac8e57999']
Antes do modulo iota ['0x967654a611a81c4e', '0x4313e32cdbacecc5',
'0x431b7a108e4163ad', '0xac2e39d2466b8ccd', '0x572cd0c83fd134e5']
Depois do modulo iota ['0x967654a611a89ccc', '0x4313e32cdbacecc5',
'0x431b7a108e4163ad', '0xac2e39d2466b8ccd', '0x572cd0c83fd134e5']
Valor atual do State Array  após a rodada 2/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0x270e43bbef410a08', '0x1f95781243e3cc1c',
'0x9581b35b8ceddf2e', '0xb96b191fd14e7a7b', '0x35bd0f0ac8e57999']
Depois de theta ['0x47a49ab35041f12c', '0x7f3fa11afce33738',
'0xf52b6a5333ed240a', '0xd9c1c0176e4e815f', '0x5517d60277e582bd']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0xf5809df960af5545',
'0x9a5b75b0df062836', '0x5620406d384cb2f2', '0xb7f1f051f4dedd82',
'0x9fef45e904524186']
Antes do modulo chi ['0x47a49ab35041f12c', '0x7f3fa11afce33738',
'0xf52b6a5333ed240a', '0xd9c1c0176e4e815f', '0x5517d60277e582bd']
Depois do modulo chi ['0xe59811f820a35c44', '0x9bd07d838f87a8e4',
'0xd631cdc9340981a2', '0xf39890637cdc9f88', '0x91cd4eb90c5b01c4']
Antes do modulo iota ['0xef8663c6bce2e43e', '0x7834f684271e7b28',
'0xeec7053f3324caf', '0x32909fc94538bcd5', '0x60d5502d91c61605']
Depois do modulo iota ['0x6f8663c6bce264b4', '0x7834f684271e7b28',
'0xeec7053f3324caf', '0x32909fc94538bcd5', '0x60d5502d91c61605']
Valor atual do State Array  após a rodada 3/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0xe59811f820a35c44', '0x9bd07d838f87a8e4',
'0xd631cdc9340981a2', '0xf39890637cdc9f88', '0x91cd4eb90c5b01c4']
Depois de theta ['0xd13bf67e220f16f4', '0xaf739a058d2be254',
'0xe2922a4f36a5cb12', '0xc73b77e57e70d538', '0xa56ea93f0ef74b74']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0xaa4fc3bdd2dd295b',
'0x9750724d194dc2e4', '0x2150bba39f8a022b', '0x50b8598a5d35665a',
'0xee28d53d409247af']
Antes do modulo chi ['0xd13bf67e220f16f4', '0xaf739a058d2be254',
'0xe2922a4f36a5cb12', '0xc73b77e57e70d538', '0xa56ea93f0ef74b74']
Depois do modulo chi ['0xfa6dc7fd1eec697f', '0x1700707b1c4db7ec',
'0xa112d6a39f8f1a2c', '0x52b0ddc25d034612', '0xba29957d50b0c7ae']
Antes do modulo iota ['0x8e453b34214c9713', '0x2c0dd0c8e85b8233',
'0x74b512db3d626628', '0x81952ab7a7c9cfb1', '0xa37e353ba25834ec']
Depois do modulo iota ['0xe453b34a14c1713', '0x2c0dd0c8e85b8233',
'0x74b512db3d626628', '0x81952ab7a7c9cfb1', '0xa37e353ba25834ec']
Valor atual do State Array  após a rodada 4/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0xfa6dc7fd1eec697f', '0x1700707b1c4db7ec',
'0xa112d6a39f8f1a2c', '0x52b0ddc25d034612', '0xba29957d50b0c7ae']
Depois de theta ['0xf98f446e4563cc00', '0x14e2f3e847c21293',
'0xa2f05530c400bf53', '0x51525e51068ce36d', '0xb9cb16ee0b3f62d1']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0xc5bb82cfd8b46e72',
'0xe18193eadc076e0', '0x1a3c735a2e65a2ba', '0x123f71d55bc546bc',
'0x666993115ea14ce8']
Antes do modulo chi ['0xf98f446e4563cc00', '0x14e2f3e847c21293',
'0xa2f05530c400bf53', '0x51525e51068ce36d', '0xb9cb16ee0b3f62d1']
Depois do modulo chi ['0xe7fbe4d118ac79fa', '0x289c5d1ea5d03ece',
'0x1abc325fae6daa5e', '0x1f6fb1db23d74378', '0x266beb3442094d68']
Antes do modulo iota ['0x159c88a13b676077', '0x591038d7e76707d1',
'0xb66db8d05ff7c40b', '0xf00f1c6085c53203', '0x9671864280477e6f']
Depois do modulo iota ['0x159c88a13b67e0fc', '0x591038d7e76707d1',
'0xb66db8d05ff7c40b', '0xf00f1c6085c53203', '0x9671864280477e6f']
Valor atual do State Array  após a rodada 5/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0xe7fbe4d118ac79fa', '0x289c5d1ea5d03ece',
'0x1abc325fae6daa5e', '0x1f6fb1db23d74378', '0x266beb3442094d68']
Depois de theta ['0x5012bb6cdeab41e2', '0x9f7502a363d706d6',
'0xad556de2686a9246', '0xa886ee66e5d07b60', '0x9182b489840e7570']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0xad2261039d5c2460',
'0xfe2c7baf63cdd367', '0xcae2f2d640218e7d', '0x1aed7bf23c1268da',
'0x40f94c308230ed3c']
Antes do modulo chi ['0x5012bb6cdeab41e2', '0x9f7502a363d706d6',
'0xad556de2686a9246', '0xa886ee66e5d07b60', '0x9182b489840e7570']
Depois do modulo chi ['0xb82f62271d3cf504', '0xf6387aef0aa56737',
'0xcaa9c6de5089ca7d', '0x83e7fa92f17e2ade', '0xca915300a33ec14']
Antes do modulo iota ['0x62405c592f990a0b', '0xb2ebfcb9060143a0',
'0xc71449c36b559bfa', '0x66d57a8f2280a9fb', '0xb08f002653ecc690']
Depois do modulo iota ['0x62405c59af990a0a', '0xb2ebfcb9060143a0',
'0xc71449c36b559bfa', '0x66d57a8f2280a9fb', '0xb08f002653ecc690']
Valor atual do State Array  após a rodada 6/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0xb82f62271d3cf504', '0xf6387aef0aa56737',
'0xcaa9c6de5089ca7d', '0x83e7fa92f17e2ade', '0xca915300a33ec14']
Depois de theta ['0x261a7f8b2502e141', '0x680d6743329b7372',
'0x549cdb7268b7de38', '0x1dd2e73ec9403e9b', '0x929c089c320df851']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0x2270c837e1464a7',
'0x8dbf488b6cb160d8', '0x743031fa7c91f58c', '0x29f592661ec1f908',
'0x7a7f73f4f8d66d9d']
Antes do modulo chi ['0x261a7f8b2502e141', '0x680d6743329b7372',
'0x549cdb7268b7de38', '0x1dd2e73ec9403e9b', '0x929c089c320df851']
Depois do modulo chi ['0x2779a8770d4c4e7', '0xd9af498a4f95e08e',
'0x5c305b8b74a49dce', '0xa9e43223ee8ff109', '0xfd7b1eccdec2e1bd']
Antes do modulo iota ['0xce2f613af00f5a9e', '0xab2338b65cca0081',
'0xd4b7950e254a972c', '0x5dea45ba0fb057be', '0x28d190c711e9435f']
Depois do modulo iota ['0x4e2f613a700fda1f', '0xab2338b65cca0081',
'0xd4b7950e254a972c', '0x5dea45ba0fb057be', '0x28d190c711e9435f']
Valor atual do State Array  após a rodada 7/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0x2779a8770d4c4e7', '0xd9af498a4f95e08e',
'0x5c305b8b74a49dce', '0xa9e43223ee8ff109', '0xfd7b1eccdec2e1bd']
Depois de theta ['0xcbf2cc34c0a0e836', '0x102a1f39ffe1cc5f',
'0x95b50d38c4d0b11f', '0x606164905efbddd8', '0x34fe487f6eb6cd6c']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0x921fdbadb35b0d3f',
'0x6c16a38e0456e519', '0x81b772dbe994ece5', '0x89bf5bc4f189c2f0',
'0x5bb344f42889825a']
Antes do modulo chi ['0xcbf2cc34c0a0e836', '0x102a1f39ffe1cc5f',
'0x95b50d38c4d0b11f', '0x606164905efbddd8', '0x34fe487f6eb6cd6c']
Depois do modulo chi ['0x3017fdacb37309b7', '0xad8bdd9a80f7e518',
'0x9577e4be1c4ec69', '0x90e5c37ef929c378', '0xce734ce43381c253']
Antes do modulo iota ['0x1c225898b7c3fa77', '0x3242804a495eaea6',
'0x241bf30ff5adfa23', '0x86812741871fa277', '0x4828d0e7c4273f76']
Depois do modulo iota ['0x9c225898b7c37a7e', '0x3242804a495eaea6',
'0x241bf30ff5adfa23', '0x86812741871fa277', '0x4828d0e7c4273f76']
Valor atual do State Array  após a rodada 8/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0x3017fdacb37309b7', '0xad8bdd9a80f7e518',
'0x9577e4be1c4ec69', '0x90e5c37ef929c378', '0xce734ce43381c253']
Depois de theta ['0xeb79380580b51a73', '0x76e51833b331f6dc',
'0xd239bbe2d202ffad', '0x4b8b06d7caefd0bc', '0x151d894d0047d197']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0x62534011f465c547',
'0x687366dce3b256bc', '0x3b9632e6e7b27a6c', '0xbac75ba7c0aac8cb',
'0x7bd1ed349b059794']
Antes do modulo chi ['0xeb79380580b51a73', '0x76e51833b331f6dc',
'0xd239bbe2d202ffad', '0x4b8b06d7caefd0bc', '0x151d894d0047d197']
Depois do modulo chi ['0x431b6071f4e5c746', '0x694b65da82b114fd',
'0x798e6b642f9e767c', '0xaac558ab80aeeccb', '0x7e99f736d0d537b4']
Antes do modulo iota ['0x4e358792fc7d99e4', '0xeec374798cd4bdbe',
'0x3567862c27c3f16d', '0xcf8a0d3af79d385', '0x7ab0c175340c5784']
Depois do modulo iota ['0x4e358792fc7d996e', '0xeec374798cd4bdbe',
'0x3567862c27c3f16d', '0xcf8a0d3af79d385', '0x7ab0c175340c5784']
Valor atual do State Array  após a rodada 9/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0x431b6071f4e5c746', '0x694b65da82b114fd',
'0x798e6b642f9e767c', '0xaac558ab80aeeccb', '0x7e99f736d0d537b4']
Depois de theta ['0x801aa1f2e564109', '0x2251afb4580292b2',
'0x3294a10af52df033', '0xe1df92c55a1d6a84', '0x35833d580a66b1fb']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0xcf560299ac7ecd60',
'0x2d053d0c0b137ebf', '0xf6a62c3e531bb876', '0x2d8ae0a80eedb50d',
'0xcd11995a02fc787f']
Antes do modulo chi ['0x801aa1f2e564109', '0x2251afb4580292b2',
'0x3294a10af52df033', '0xe1df92c55a1d6a84', '0x35833d580a66b1fb']
Depois do modulo chi ['0xea710609307e6870', '0xf6443d0400115fa7',
'0x86e7442341138887', '0x298fad6fa84d370e', '0xad0599524f7d3e5d']
Antes do modulo iota ['0x4a88886c41ee586d', '0x24a492b3a4b89406',
'0x87be9462ed33c802', '0xb9faa228414e79fc', '0x1de0af85206e9884']
Depois do modulo iota ['0x4a88886c41ee58e5', '0x24a492b3a4b89406',
'0x87be9462ed33c802', '0xb9faa228414e79fc', '0x1de0af85206e9884']
Valor atual do State Array  após a rodada 10/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0xea710609307e6870', '0xf6443d0400115fa7',
'0x86e7442341138887', '0x298fad6fa84d370e', '0xad0599524f7d3e5d']
Depois de theta ['0x193ebc27fdb2d0e9', '0x50b872acddde73e',
'0x75a8fe0d8cdf301e', '0xdac0174165818f97', '0x5e4a237c82b186c4']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0x88df20ac61b11792',
'0x868f22f1afded155', '0xa04a8becfce7d780', '0x59dac4448fdd42dd',
'0x479de00dc7b9b105']
Antes do modulo chi ['0x193ebc27fdb2d0e9', '0x50b872acddde73e',
'0x75a8fe0d8cdf301e', '0xdac0174165818f97', '0x5e4a237c82b186c4']
Depois do modulo chi ['0xd5e8d0a85d351737', '0xa4872f779d5ec1d5',
'0x80de9ff494c0cfc0', '0x19c8ed7c0ddd40df', '0xce96c42d6bddf109']
Antes do modulo iota ['0x880ffb43737f5a', '0xd9b5d078cd60cc3c',
'0xd762a9e69210a5b9', '0xa2cd92c47dd9754c', '0x60d09b55519b3df2']
Depois do modulo iota ['0x880ffbc373ff53', '0xd9b5d078cd60cc3c',
'0xd762a9e69210a5b9', '0xa2cd92c47dd9754c', '0x60d09b55519b3df2']
Valor atual do State Array  após a rodada 11/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0xd5e8d0a85d351737', '0xa4872f779d5ec1d5',
'0x80de9ff494c0cfc0', '0x19c8ed7c0ddd40df', '0xce96c42d6bddf109']
Depois de theta ['0x532dcd5b8f5fc2a3', '0x224232844f341441',
'0x61b820746aa1a54', '0x9f0df08fdfb7954b', '0x4853d9deb9b7249d']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0xf677ae6dc9275214',
'0x539ae054e34dbbd7', '0x598cf4603ad6692', '0x46e896a67ad4e3ed',
'0x43506a2a1f2d9546']
Antes do modulo chi ['0x532dcd5b8f5fc2a3', '0x224232844f341441',
'0x61b820746aa1a54', '0x9f0df08fdfb7954b', '0x4853d9deb9b7249d']
Depois do modulo chi ['0xf6758e7dd5a15eb5', '0x53dab015e75d9bd4',
'0x1cc7d8327a04222', '0x646d96ec7ed0637d', '0xc9f06a2a9fec9747']
Antes do modulo iota ['0xabed4fcee169e24a', '0x7e36a304e3abcd64',
'0x8ba94d32d2d0514b', '0xd83a33951b1b352e', '0x70547baa4732f8fe']
Depois do modulo iota ['0xabed4fce6169e240', '0x7e36a304e3abcd64',
'0x8ba94d32d2d0514b', '0xd83a33951b1b352e', '0x70547baa4732f8fe']
Valor atual do State Array  após a rodada 12/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0xf6758e7dd5a15eb5', '0x53dab015e75d9bd4',
'0x1cc7d8327a04222', '0x646d96ec7ed0637d', '0xc9f06a2a9fec9747']
Depois de theta ['0x2ffe69b1322a57ca', '0x8a5157d900d692ab',
'0xd8479a4fc02b4b5d', '0xbde67120995b6a02', '0x107b8de678679e38']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0xe3799e19e78e041e',
'0x265c96ee3ca4e114', '0xbde614dc1c0f80c6', '0x8328d6358bc97bbc',
'0x7c16a4767aad3411']
Antes do modulo chi ['0x2ffe69b1322a57ca', '0x8a5157d900d692ab',
'0xd8479a4fc02b4b5d', '0xbde67120995b6a02', '0x107b8de678679e38']
Depois do modulo chi ['0x63299e9bbf1fa65e', '0x3bcc96863c2ce015',
'0xfdeef4dd89562086', '0x914aff352fc9778e', '0x2d16f072af3d701b']
Antes do modulo iota ['0x3fabe56987641da5', '0xe20bbd81aa34b63c',
'0x8b941d6460861b8d', '0xed81c4de59ff73cd', '0xace92bba2863ab70']
Depois do modulo iota ['0x3fabe56907649d2e', '0xe20bbd81aa34b63c',
'0x8b941d6460861b8d', '0xed81c4de59ff73cd', '0xace92bba2863ab70']
Valor atual do State Array  após a rodada 13/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0x63299e9bbf1fa65e', '0x3bcc96863c2ce015',
'0xfdeef4dd89562086', '0x914aff352fc9778e', '0x2d16f072af3d701b']
Depois de theta ['0x9525aaeaecd2efed', '0xcdc0a2f76fe1a9a6',
'0xbe2c0acda9b6935', '0x6746cb447c043e3d', '0xdb1ac403fcf039a8']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0xb100ff3c0e6a36c6',
'0x32c4647351c906ce', '0x12735363bb594189', '0x7ffe5e101e07db8a',
'0x771e51e3d4872c2']
Antes do modulo chi ['0x9525aaeaecd2efed', '0xcdc0a2f76fe1a9a6',
'0xbe2c0acda9b6935', '0x6746cb447c043e3d', '0xdb1ac403fcf039a8']
Depois do modulo chi ['0xb5c89fbc0e4a1697', '0x1fd0d07953a99ece',
'0x8067d2661b510081', '0x576776909e03d9aa', '0x2171c61e6a58c7c0']
Antes do modulo iota ['0x83061836f6ded8a8', '0x82eb4bf1d81d66ea',
'0x6de366f04b653e97', '0x4466d33b6be9b85d', '0x513b48ffa8ec02dd']
Depois do modulo iota ['0x3061836f6ded823', '0x82eb4bf1d81d66ea',
'0x6de366f04b653e97', '0x4466d33b6be9b85d', '0x513b48ffa8ec02dd']
Valor atual do State Array  após a rodada 14/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0xb5c89fbc0e4a1697', '0x1fd0d07953a99ece',
'0x8067d2661b510081', '0x576776909e03d9aa', '0x2171c61e6a58c7c0']
Depois de theta ['0x4047a0f94fac3036', '0xea5fef3c124fb86f',
'0x75e8ed235ab72620', '0xa2e849d5dfe5ff0b', '0xd4fef95b2bbee161']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0xbe56caefb858753f',
'0xaa7f90daff3d2845', '0x5719a61bd67c8d06', '0x3308cdb1d6b0988f',
'0x7f232edb72e22213']
Antes do modulo chi ['0x4047a0f94fac3036', '0xea5fef3c124fb86f',
'0x75e8ed235ab72620', '0xa2e849d5dfe5ff0b', '0xd4fef95b2bbee161']
Depois do modulo chi ['0x3a54eacf3813b525', '0x7bbf9410fdf32801',
'0xd713683bc64c8866', '0x2608d7bfdfa9d80f', '0xff21069b74e272d5']
Antes do modulo iota ['0x31fdcf9f77343f25', '0x2a112231f531edba',
'0x7aa1310dea8eea9c', '0x8afb608100a43e0d', '0x21fcd735a9190c09']
Depois do modulo iota ['0xb1fdcf9f7734bfac', '0x2a112231f531edba',
'0x7aa1310dea8eea9c', '0x8afb608100a43e0d', '0x21fcd735a9190c09']
Valor atual do State Array  após a rodada 15/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0x3a54eacf3813b525', '0x7bbf9410fdf32801',
'0xd713683bc64c8866', '0x2608d7bfdfa9d80f', '0xff21069b74e272d5']
Depois de theta ['0x8f662112c135ab2', '0x491d1ccee9f3c796',
'0xe5b1e0e5d24c67f1', '0x14aa5f61cba93798', '0xcd838e4560e29d42']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0xe3915838a750b360',
'0x8adf6f43a3f59e96', '0xf96828e75e24799a', '0xd794bcc426b4e909',
'0x530fd2279d84ac97']
Antes do modulo chi ['0x8f662112c135ab2', '0x491d1ccee9f3c796',
'0xe5b1e0e5d24c67f1', '0x14aa5f61cba93798', '0xcd838e4560e29d42']
Depois do modulo chi ['0x9291003a853bb320', '0x659674ba3d11f17',
'0xc96800c51e643c12', '0xb787dde46e04edec', '0x4acf8017fd90a4b3']
Antes do modulo iota ['0x63c227c0904343a', '0x437897347b49185a',
'0x4ccd861996abaa45', '0x87800a8b940cf910', '0x6423a80b98e2f652']
Depois do modulo iota ['0x863c227c0904b439', '0x437897347b49185a',
'0x4ccd861996abaa45', '0x87800a8b940cf910', '0x6423a80b98e2f652']
Valor atual do State Array  após a rodada 16/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0x9291003a853bb320', '0x659674ba3d11f17',
'0xc96800c51e643c12', '0xb787dde46e04edec', '0x4acf8017fd90a4b3']
Depois de theta ['0x530d6da720831565', '0xc7c50ad60669b952',
'0x8f46d58bbdc9a57', '0x761bb079cbbc4ba9', '0x8b53ed8a582802f6']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0xfb62960a00bda2d4',
'0x2b82bf2d869771c7', '0xa6081b1516730eac', '0x16671b48f479003c',
'0x2189bd4b01d4af70']
Antes do modulo chi ['0x530d6da720831565', '0xc7c50ad60669b952',
'0x8f46d58bbdc9a57', '0x761bb079cbbc4ba9', '0x8b53ed8a582802f6']
Depois do modulo chi ['0x7f609e02002dd2dc', '0xa3a29f2f16976987',
'0xe400395a047286ac', '0x508dba0cb17800ae', '0xf8d6fdf1516bf72']
Antes do modulo iota ['0x71b41763182107d6', '0x7748cedd477ee59c',
'0x39f14090edd215b3', '0x10155c0a0ad4fb6d', '0xd0fb2c43a939e294']
Depois do modulo iota ['0xf1b41763182187d4', '0x7748cedd477ee59c',
'0x39f14090edd215b3', '0x10155c0a0ad4fb6d', '0xd0fb2c43a939e294']
Valor atual do State Array  após a rodada 17/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0x7f609e02002dd2dc', '0xa3a29f2f16976987',
'0xe400395a047286ac', '0x508dba0cb17800ae', '0xf8d6fdf1516bf72']
Depois de theta ['0xeecfa8bcd4179b59', '0x320da991c2ad2002',
'0x75af0fe4d048cf29', '0xc1228cb26542492b', '0x9e225961c12cf6f7']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0x9658704b3dbde788',
'0xaf4b6d926ea8981e', '0x70736c42e4ad929b', '0x34fd868fdfffc459',
'0xe099e97a7bb9bdcc']
Antes do modulo chi ['0xeecfa8bcd4179b59', '0x320da991c2ad2002',
'0x75af0fe4d048cf29', '0xc1228cb26542492b', '0x9e225961c12cf6f7']
Depois do modulo chi ['0x165a68cbbc4ac788', '0x3f4f6f426e89981c',
'0xfdf26c6234ed07ba', '0x25a6c4abeffe447b', '0xe05deefb29a1acfc']
Antes do modulo iota ['0x3968e76f740898cb', '0x2f9b3c063a422bf8',
'0x627e2e5e27ab4ad2', '0x6e24a81983d27a15', '0xff1a38182581e685']
Depois do modulo iota ['0xb968e76f7408984b', '0x2f9b3c063a422bf8',
'0x627e2e5e27ab4ad2', '0x6e24a81983d27a15', '0xff1a38182581e685']
Valor atual do State Array  após a rodada 18/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0x165a68cbbc4ac788', '0x3f4f6f426e89981c',
'0xfdf26c6234ed07ba', '0x25a6c4abeffe447b', '0xe05deefb29a1acfc']
Depois de theta ['0x819d7a0553e9d191', '0xa8887d8c812a8e05',
'0x6a357eacdb4e11a3', '0xb261d665005d5262', '0x779afc35c602bae5']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0xbf0d7180aeb95de6',
'0x1761d76ee92181a7', '0x5344baebd5e28d8f', '0xfbb8912a683bbcd9',
'0x7bc5ad6da7c5f18c']
Antes do modulo chi ['0x819d7a0553e9d191', '0xa8887d8c812a8e05',
'0x6a357eacdb4e11a3', '0xb261d665005d5262', '0x779afc35c602bae5']
Depois do modulo chi ['0xa5a5f1992efd5def', '0x7a9c5e6496389a2',
'0x96a5bea3ddc284bb', '0xeeb811795a1ab8fa', '0x3ef2cd69a7c5308c']
Antes do modulo iota ['0x24031aa67db3adb2', '0xed34e8215e9dc28a',
'0x321a3005f447d6cb', '0x62fb7c244cdc2adc', '0xba480b7ac37c0c77']
Depois do modulo iota ['0x24031aa67db32db8', '0xed34e8215e9dc28a',
'0x321a3005f447d6cb', '0x62fb7c244cdc2adc', '0xba480b7ac37c0c77']
Valor atual do State Array  após a rodada 19/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0xa5a5f1992efd5def', '0x7a9c5e6496389a2',
'0x96a5bea3ddc284bb', '0xeeb811795a1ab8fa', '0x3ef2cd69a7c5308c']
Depois de theta ['0xe18b6f217b1def1', '0xac14828d702f0abc',
'0x3d18f9c8e48e07a5', '0x4505561263563be4', '0x954f8a029e89b392']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0xe280a7a26ce4a553',
'0xf3182b4905a5be4d', '0x8c4308a32c0304c2', '0xe4b3e8d27fcc5453',
'0x5f66ba84e5d78167']
Antes do modulo chi ['0xe18b6f217b1def1', '0xac14828d702f0abc',
'0x3d18f9c8e48e07a5', '0x4505561263563be4', '0x954f8a029e89b392']
Depois do modulo chi ['0xc200ef91efe4b053', '0xf3cc2909266f3f05',
'0xa8ce08e73d0050e3', '0x88b3b9da1b485453', '0xfe4ebac4f5978077']
Antes do modulo iota ['0x1b1db7cc5cd7eabb', '0xba2ba1b0c8247e00',
'0x8b729f99ac7c239c', '0x93970ef7184846b5', '0x5c164fafe89ff6ed']
Depois do modulo iota ['0x9b1db7ccdcd7eab1', '0xba2ba1b0c8247e00',
'0x8b729f99ac7c239c', '0x93970ef7184846b5', '0x5c164fafe89ff6ed']
Valor atual do State Array  após a rodada 20/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0xc200ef91efe4b053', '0xf3cc2909266f3f05',
'0xa8ce08e73d0050e3', '0x88b3b9da1b485453', '0xfe4ebac4f5978077']
Depois de theta ['0x282a82e4b1740616', '0x19e6447c78ff8940',
'0x42e465926390e6a6', '0x6299d4af45d8e216', '0x1464d7b1ab073632']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0x35ec6ac1cd8c8519',
'0xaac721b9d6a41182', '0x7561e17f371a2d4a', '0x41e7658567bab7f1',
'0x4a5d6c4f42fd0a0f']
Antes do modulo chi ['0x282a82e4b1740616', '0x19e6447c78ff8940',
'0x42e465926390e6a6', '0x6299d4af45d8e216', '0x1464d7b1ab073632']
Depois do modulo chi ['0xa468f0417e24af1d', '0xea862e8146a493e6',
'0x754559b3339a074b', '0xcba33703210c9791', '0x425dec6576f50209']
Antes do modulo iota ['0x86b207f0c579558', '0x2796b0c06e133d09',
'0x139b43113157d03e', '0x48b8030b949dc1d', '0xf20f5b95c2d7e738']
Depois do modulo iota ['0x886b207f8c5715d9', '0x2796b0c06e133d09',
'0x139b43113157d03e', '0x48b8030b949dc1d', '0xf20f5b95c2d7e738']
Valor atual do State Array  após a rodada 21/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0xa468f0417e24af1d', '0xea862e8146a493e6',
'0x754559b3339a074b', '0xcba33703210c9791', '0x425dec6576f50209']
Depois de theta ['0x350d55d109a3223c', '0x7be38b1131231ec7',
'0xe420fc23441d8a6a', '0x5ac69293568b1ab0', '0xd33849f501728f28']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0x127d405ca3ca34ce',
'0x1699a47c4f44cb2e', '0xc25a539d5d48fea2', '0x9a374a7b2a61dfa8',
'0x5864483f906f2d00']
Antes do modulo chi ['0x350d55d109a3223c', '0x7be38b1131231ec7',
'0xe420fc23441d8a6a', '0x5ac69293568b1ab0', '0xd33849f501728f28']
Depois do modulo chi ['0x887e64dd86527cc2', '0x168bb64c0b65eb2e',
'0x429c42c11d58d3fb', '0x98078c5528744bb9', '0x7a046aba9cea2c92']
Antes do modulo iota ['0x65c4db1e5a65b673', '0xbf656d4bba5edf78',
'0x6318cca2a6e392a6', '0xa84a1951b1882a22', '0x59045c3a62727e65']
Depois do modulo iota ['0xe5c4db1e5a6536f3', '0xbf656d4bba5edf78',
'0x6318cca2a6e392a6', '0xa84a1951b1882a22', '0x59045c3a62727e65']
Valor atual do State Array  após a rodada 22/24

Antes de theta ['0x0', '0x0', '0x0', '0x0', '0x0']
Depois da rotacao de theta A[ 4 ] ['0x887e64dd86527cc2', '0x168bb64c0b65eb2e',
'0x429c42c11d58d3fb', '0x98078c5528744bb9', '0x7a046aba9cea2c92']
Depois de theta ['0x8022b2c1e2e05ca1', '0x1ed760506fd7cb4d',
'0x4ac094dd79eaf398', '0x905b5a494cc66bda', '0x7258bca6f8580cf1']
Antes de rho e pi ['0x0', '0x0', '0x0', '0x0', '0x0']

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0x2f29be16033c5c96',
'0xbe7225671b122cff', '0xcb7bb3596cf3ad12', '0x414efeb2390be22b',
'0x5a3f2248aa60716']
Antes do modulo chi ['0x8022b2c1e2e05ca1', '0x1ed760506fd7cb4d',
'0x4ac094dd79eaf398', '0x905b5a494cc66bda', '0x7258bca6f8580cf1']
Depois do modulo chi ['0xa768f4162114b0d3', '0xbe72295b9f13ecff',
'0xca29335964fafd12', '0x1e65ea2eb53c84a', '0x136ed22c1a848506']
Antes do modulo iota ['0x379c25badc13139a', '0xb55ff1c239da3dff',
'0x62253c1f7676ac5c', '0x1f470ae22087d59e', '0x80305d3561d858ee']
Depois do modulo iota ['0x379c25ba5c13139b', '0xb55ff1c239da3dff',
'0x62253c1f7676ac5c', '0x1f470ae22087d59e', '0x80305d3561d858ee']
Valor atual do State Array  após a rodada 23/24

Depois de rho e pi e da rotacao em A[ 4 ][ 4 ] ['0x4f856be129a79e1a',
'0x5e97f2703a9dc20d', '0x360dd2eadc48675f', '0xd9ee69b0dfebe541',
'0x2da6e48c94a04ce3']
Antes do modulo chi ['0xcc6f182f9414934b', '0xd575c5622a13cf67',
'0xa12edf60d1fade8a', '0x6ae1b29b5e53ebd2', '0x78693e15af84a69e']
Depois do modulo chi ['0xe8161b00b239c0a', '0x5eb7d37ca8b8c51d',
'0x1e1dc2e7fe50741f', '0x5ae369905e6fe243', '0xd56e4ae3e840ae7']
Antes do modulo iota ['0xbecbe58edc73fcc7', '0xd7ca84b26d5ad8ce',
'0xd7a7e5f0cce6ac05', '0x48c0611b7a1a185d', '0xde09ed9d15532991']
Depois do modulo iota ['0x3ecbe58e5c737ccf', '0xd7ca84b26d5ad8ce',
'0xd7a7e5f0cce6ac05', '0x48c0611b7a1a185d', '0xde09ed9d15532991']
Valor atual do State Array  após a rodada 24/24
\end{verbatim}

\end{enumerate}

\item Apresente uma implementação do SHA3.\\

O código está comentado no arquivo \verb|keccak/keccak.py|. E as 6 funções
do SHA-3 estão contidas no arquivo \verb|keccak/demo.py|. Mais 6 funções que
processam blocos de dados para responder as questões abaixo.

\begin{enumerate}

\item Descreva a implementação.\\

O anexo ao final desse pdf, contêm o código descrito \ref{codeprint}.\\

\item Mostre \underline{na implementação} onde se da cada passo importante do
cálculo do hash.\\

Em anexo no final desse \verb|pdf| esta o código keccak/keccak.py. Em negrito
está selecionado a parte importante para o cálculo do resumo criptográfico. As
partes cruciais para o calculo do hash são \ref{codeprint}:\\

  \begin{enumerate}
    \item Preenchendo (pad10*1)
    \item Absorvendo da Esponja (absorving)
    \item Espremendo da Esponja (squeezing)\\
  \end{enumerate}

\item Execute a implementação passo a passo, mostrando o maior número possível
de saídas.\\

Primeiro eu testei para ver se o código esta funcionando corretamente, Rodando
python3 keccak/test.py irá processar os arquivos abaixo listados Esse teste esta
disponível no site di-mgt.com.au/sha\_testvectors.html \cite{testskat}. Todos os
testes com os arquivos abaixo foram processados e passaram OK nos testes.\\

  \begin{enumerate}
    \item ShortMsgKAT.txt
    \item ShortMsgKAT\_0.txt
    \item ShortMsgKAT\_224.txt
    \item ShortMsgKAT\_256.txt
    \item ShortMsgKAT\_384.txt
    \item ShortMsgKAT\_512.txt
  \end{enumerate}

Agora a questão pede "execute a implementação passo a passo, mostrando o maior
número possível de saídas". {\bfseries Então as saídas estão em anexo ao final
do} \verb|pdf| \ref{saidasprograma}. Eu rodei o código para \textbf{M} =
{\color{Red} \verb|'abc'|} a fim de certificar que estava rodando corretamente.
Os resultados bateram. Basta ir até o diretório do código keccak dentro do zip e
rodar python3 demo.py. Ele lhe perguntará o que você deseja fazer 's' para
verificar os tempos de processamento de 65 KB de dados (gerados internamente).

  \begin{verbatim}
    Retirado do site: http://www.di-mgt.com.au/sha_testvectors.html
    Input message: "abc" (length 24 bits).

    SHA-3-224 e642824c3f8cf24a d09234ee7d3c766f
              c9a3a5168d0c94ad 73b46fdf

    SHA-3-256 3a985da74fe225b2 045c172d6bd390bd
              855f086e3e9d525b 46bfe24511431532

    SHA-3-384 ec01498288516fc9 26459f58e2c6ad8d
              f9b473cb0fc08c25 96da7cf0e49be4b2
              98d88cea927ac7f5 39f1edf228376d25

    SHA-3-512 b751850b1a57168a 5693cd924b6b096e
              08f621827444f70d 884f5d0240d2712e
              10e116e9192af3c9 1a7ec57647e39340
              57340b4cf408d5a5 6592f8274eec53f0
  \end{verbatim}

  Rodando agora meu programa. Para conferir. Lembrando que a execução passo a
  passo, mostrando o maior número possível de saídas esta em anexo nesse pdf ao
  final dele \ref{saidasprograma}.\\

  \begin{verbatim}
    /usr/bin/python3.4 keccak/demo.py
    Verificar tempos de processamento de blocos? (s/n): n

    Mensagem (para testar todos os digests sha3: abc

    Comparar com www.di-mgt.com.au/sha_testvectors.html

    'SHA3_224' - 0.00282 sec

    Resumo: e642824c3f8cf24a d09234ee7d3c766f c9a3a5168d0c94ad 73b46fdf

    'SHA3_256' - 0.00477 sec

    Resumo: 3a985da74fe225b2 045c172d6bd390bd 855f086e3e9d525b 46bfe24511431532

    'SHA3_384' - 0.00447 sec

    Resumo: ec01498288516fc9 26459f58e2c6ad8d f9b473cb0fc08c25 96da7cf0e49be4b2
    98d88cea927ac7f5 39f1edf228376d25

    'SHA3_512' - 0.00381 sec

    Resumo: b751850b1a57168a 5693cd924b6b096e 08f621827444f70d 884f5d0240d2712e
    10e116e9192af3c9 1a7ec57647e39340 57340b4cf408d5a5 6592f8274eec53f0

    'SHAKE128' - 0.00168 sec

    Resumo: 5881092dd818bf5c f8a3ddb793fbcba7 4097d5c526a6d35f 97b83351940f2cc8
    44c50af32acd3f2c dd066568706f509b c1bdde58295dae3f 891a9a0fca578378

    'SHAKE256' - 0.00167 sec

    Resumo: 483366601360a877 1c6863080cc4114d 8db44530f8f1e1ee 4f94ea37e78b5739
    d5a15bef186a5386 c75744c0527e1faa 9f8726e462a12a4f eb06bd8801e751e4
  \end{verbatim}
\end{enumerate}

\item Compare o SHA3, em termos de performance, com os hashes da família SHA2.
Use um mesmo computador e implementações padrão para esta comparação. O
resultado da comparação deve ser em termos de tamanhos de arquivos dos quais
hashes são calculados e quanto tempo para hash (uma média) demora para ser
calculado.\\

  Configurações para os ensaios com os resumos criptográficos eu não utilizei
  openssl speed, eu criei um programa para calcular o tempo processando blocos
  de dados. O conjunto de blocos de strings (1024 bytes cada) é o mesmo para
  todos os ensaios.:

  \begin{enumerate}
    \item Fluxo: \verb|1024 bytes/bloco| $\times$ \verb|64 blocos|
    \item Total: \verb|65,536 KB| de informação
    \item Sistema Operacional: \verb|Linux 3.13.0-55-generic Ubuntu|
    \item Data do Ensaio: Terça Junho 18 00:27:10 UTC 2015
    \item Arquitetura: \verb|x86 64 GNU/Linux|
    \item Bibliotecas: hashlib (para família SHA-2)
    \item Linguagem: python3.4
    \item python 3 demo.py
    \item Função Esponja: Keccak (para família SHA-3)
    \item codificação: base 16
  \end{enumerate}

  Tempos da familia SHA-3, processando os blocos para 64 bytes/bloco * 1024
  blocos -- totalizando 65 KB de dados\\

  \begin{itemize}
    \item
    0.00025 sec
    1024 blocos processados com sha3 256

    \item
    1.67190 sec
    1024 blocos processados com sha3 256

    \item
    1.67232 sec
    1024 blocos processados com sha3 384

    \item
    1.64219 sec
    1024 blocos processados com sha3 512

    \item
    1.67886 sec
    1024 blocos processados com shake128

    \item
    1.68294 sec
    1024 blocos processados com shake256\\
  \end{itemize}

    Tempos da familia SHA-2, processando os blocos\\

  \begin{itemize}
    \item
    0.00161 segundos
    1024blocos processados com sha224

    \item
    0.00166 segundos
    1024blocos processados com sha256

    \item
    0.00179 segundos
    1024blocos processados com sha384

    \item
    0.00173 segundos
    1024 blocos processados com sha512
  \end{itemize}

\item Apresente uma crítica ao SHA3.\\

  \begin{enumerate}
    \item O que ele é melhor ou diferente em relação a outros hash?\\

    Suas 2 funções de vazão estendida são o diferencial (para melhor adaptação a
    implementações de hardware e software), as chamadas XOF's SHA-3
    (e\textbf{X}tended \textbf{O}utput \textbf{F}unctions \textbf{S}ecure
    \textbf{H}ash \textbf{A}lgorithm) \ref{sha3-inicial}. Porém fazendo a
    análise de tempos de processamento de blocos de string no item anterior a
    família SHA-2 processa mais rapidamente, isso me diz que ela é mais adaptada
    à software (com optimizações para software). Porém o SHA-3 é mais adaptado a
    hardware, ou seja, o foco do SHA-3 é para ser implementado em hardware
    (p.e.: Sistemas Embarcados).\\

    \item Quanto tempo você acha (e por que) o SHA3 será considerado seguro?\\

    O pesquisador Razvan Rosie publicou em 10 Dezembro de 2014 um artigo
    explorando \textit{On quantum preimage attacks} onde ele propõe um ataque à
    pré imagem do SHA-3 (que por sua vez usa o \textit{Keccak-f}) contra as
    funções de hash criptográfico. Baseado em aumentar a velocidade dos
    cálculos, usando computação quântica (inglês.: \textit{Quantum preimage
    attack}). Resistência a pré imagem é uma propriedade \textbf{fundamental}, e
    o artigo de Rosie aborda um algoritmo capaz de identificar um valor de pré
    imagem $x$ do espaço de entrada de $h \in \mathbb{Z}_{2}^{inf} \rightarrow
    \mathbb{Z}_{2}^{N}$ \cite{rosie14}, atingindo o objetivo que é quebrar a
    regra de resistência a pré imagem (propriedade de uma via): $resumo_y\ =
    HashFunction_x(Messagem);\ resumo_y \rightarrow Mensagem$
    \underline{\color{red} \textbf{mas}} \underline{\color{red} \textbf{nunca}}
    $Mensagem \rightarrow resumo_y$. Isto é, do $resumo_y$ aponta para uma
    mensagem, mas \textbf{\underline{nunca}} o contrário (isso é resistência a
    pré imagem).\\

    O por quê de eu ter trazido essa notícia logo acima do artigo do Razvan
    Rosie é que antes mesmo do SHA-3 estar vinculado, ativamente, ao mercado de
    resumos criptográfico. Já estão lançando técnicas bastante modernas para
    tentar quebrar o algoritmo SHA-3 de alguma forma. Forçando a pensar que ele
    pode ter uma vida curta. Porém a tabela a seguir mostra que não é verdade
    isso. Que o SHA-3 vai perdurar por um bom tempo ainda.\\

    \begin{table}[ht!]
      \centering
      \begin{tabular}{|l|c|c|c|c|}
        \hline Funções & Ininterrupto & Enfraquecido & Quebrado & Depreciado \\
        \hline SHA-1 & 1995-2003 (9) & 2004-2012 (9) & | & | \\
        \hline SHA-2 (Família) & 2000-2007 (8) & 2008-2012 (5) & | & | \\
        \hline SHA-3 (Keccak) & 2009-2012 (4) & | & | & | \\
        \hline
      \end{tabular}
      \caption{Tabela comparativa das família SHA-1, SHA-2 e SHA-3 e sua
      estabilidade no mercado de resumos criptográficos, a tabela foi produzida
      a partir dos dados do site http://valerieaurora.org/hash.html Copyright
      2007 - 2012 Valerie Aurora, licensed CC-BY-SA.}
    \end{table}

    Segundo o site http://valerieaurora.org/hash.html (Valerie Aurora, 2007 |
    2012) vemos que o SHA-3 está com estado Ininterrupto (Unbroken) desde 2009
    até 2012 são 4 anos. Se o SHA-2 está desde 2000 até 2007 Ininterrupto e
    desde 2008 até 2012, Enfraquecido (Weakened) são 13 anos no total resistindo
    no mercado de resumos criptográficos, sendo que o SHA-2 é de uso oficial no
    Brasil. Agora o SHA-1 ainda não passou para o estado de Quebrado (Broken) e
    ele resiste desde 1995 até 2012, são 18 anos. Se somarmos 18 anos (SHA-1)
    mais 12 anos (SHA-2) dá 30 anos, talvez isso seja um exagero para o SHA-3
    (30 anos de resistência). Daqui a 15 anos nós estaremos embarcando no mundo
    da computação quântica. Pode chutar um valor de aproximadamente 15 anos para
    o SHA-3 ser quebrado.

  \end{enumerate}

\end{enumerate}

\pagebreak
\begin{thebibliography}{9}
\bibitem{sakura} G. Bertoni, J. Daemen, M. Peeters, and G. Van Assche, “SAKURA:
a flexible coding for tree hashing,”. Disponível em:
\href{http://keccak.noekeon.org/Sakura.pdf}{pdf}.

\bibitem {gbertoni} G. Bertoni, J. Daemen, M. Peeters, and G. Van Assche,
“Cryptographic sponge functions,” Janeiro 2011, Disponível em:
\href{http://sponge.noekeon.org/CSF-0.1.pdf}{pdf}.

\bibitem{nist} NIST Computer Security Division (CSD). SHA-3 Standard:
Permutation-Based Hash and Extendable-Output Functions. 2014.

\bibitem{fips} Federal Information Processing Standards Publication 180-4,
Secure Hash Standard (SHS), Information Technology Laboratory, National
Institute of Standards and Technology, Março 2012, Disponível em:
\href{http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf}{pdf}.

\bibitem{sha3} The SHA-3 Cryptographic Hash Algorithm Competition, Novembro
2007-Outubro 2012, Diponível na:
\href{http://csrc.nist.gov/groups/ST/hash/sha-3/index.html}{web}.

\bibitem{keccak} G. Bertoni, J. Daemen, M. Peeters, and G. Van Assche, “Keccak
Specifications,” Submission to NIST (Round 3), Janeiro 2011, Disponível em:
\href{http://keccak.noekeon.org/Keccak-submission-3.pdf}{pdf}.

\bibitem{bertoni} G. Bertoni, J. Daemen, M. Peeters, and G. Van Assche, “The
Keccak reference, Version 3.0,” Janeiro 2011, Disponível em:
\href{http://keccak.noekeon.org/Keccak-reference-3.0.pdf}{pdf}.

\bibitem{rosie14} Rosie, Razvan. \textit{On quantum preimage attacks}.
Disponível em: arXiv:1412.3164

\bibitem{testskat} Keccak: Known-answer and Monte Carlo test results, Version
3.0, January 14, 2011, [download disponível em:
\href{http://keccak.noekeon.org/KeccakKAT-3.zip}{KeccakKAT-3.zip}].
\end{thebibliography}

\smallskip
\pagebreak

\section{Anexos}

\subsection{Anexos}
\label{saidasprograma}
\input{saida.tex}

\subsection{Código}
\label{codeprint}

Apresentação do código comentado (escrito em Python 3) \verb|keccak/keccak.py|.
Abaixo segue autores e licença do código. Extraído do código em si disponível
em: \href{http://keccak.noekeon.org/}{http://keccak.noekeon.org/}.

\begin{verbatim}
# The Keccak sponge function, designed by Guido Bertoni, Joan Daemen,
# Michaël Peeters and Gilles Van Assche. For more information, feedback or
# questions, please refer to our website: http://keccak.noekeon.org/
#
# Implementation by Renaud Bauvin,
# hereby denoted as "the implementer".
#
# To the extent possible under law, the implementer has waived all copyright
# and related or neighboring rights to the source code in this file.
# http://creativecommons.org/publicdomain/zero/1.0/
\end{verbatim}

\end{document}
